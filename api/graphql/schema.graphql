# GraphQL Schema for Ethereum Blockchain Indexer

# Scalar types for Ethereum data
# Bytes represents hex-encoded bytes (0x...)
scalar Bytes

# BigInt represents large integers as strings
scalar BigInt

# Address represents an Ethereum address (0x...)
scalar Address

# Hash represents a 32-byte hash (0x...)
scalar Hash

# Block represents an Ethereum block
type Block {
  # Block number (height)
  number: BigInt!

  # Block hash
  hash: Hash!

  # Parent block hash
  parentHash: Hash!

  # Timestamp of the block
  timestamp: BigInt!

  # Block nonce
  nonce: Bytes!

  # Miner address (coinbase)
  miner: Address!

  # Difficulty
  difficulty: BigInt!

  # Total difficulty
  totalDifficulty: BigInt

  # Gas limit
  gasLimit: BigInt!

  # Gas used
  gasUsed: BigInt!

  # Base fee per gas (EIP-1559, post-London)
  baseFeePerGas: BigInt

  # Withdrawals merkle root (post-Shanghai)
  withdrawalsRoot: Hash

  # Blob gas used (EIP-4844)
  blobGasUsed: BigInt

  # Excess blob gas (EIP-4844)
  excessBlobGas: BigInt

  # Extra data
  extraData: Bytes!

  # Size in bytes
  size: BigInt!

  # Transactions in this block
  transactions: [Transaction!]!

  # Transaction count
  transactionCount: Int!

  # Uncle blocks (ommers)
  uncles: [Hash!]!
}

# Transaction represents an Ethereum transaction
type Transaction {
  # Transaction hash
  hash: Hash!

  # Block number containing this transaction
  blockNumber: BigInt!

  # Block hash containing this transaction
  blockHash: Hash!

  # Transaction index in block
  transactionIndex: Int!

  # From address
  from: Address!

  # To address (null for contract creation)
  to: Address

  # Value transferred
  value: BigInt!

  # Gas limit
  gas: BigInt!

  # Gas price
  gasPrice: BigInt

  # Max fee per gas (EIP-1559)
  maxFeePerGas: BigInt

  # Max priority fee per gas (EIP-1559)
  maxPriorityFeePerGas: BigInt

  # Transaction type (0x00, 0x02, 0x03, 0x16)
  type: Int!

  # Input data
  input: Bytes!

  # Nonce
  nonce: BigInt!

  # V signature value
  v: BigInt!

  # R signature value
  r: Bytes!

  # S signature value
  s: Bytes!

  # Chain ID
  chainId: BigInt

  # Access list (EIP-2930)
  accessList: [AccessListEntry!]

  # Transaction receipt
  receipt: Receipt

  # Fee payer address (Fee Delegation, type 0x16)
  feePayer: Address

  # Fee payer signatures (Fee Delegation, type 0x16)
  feePayerSignatures: [FeePayerSignature!]
}

# FeePayerSignature represents a fee payer signature in Fee Delegation transactions
type FeePayerSignature {
  # V signature value
  v: BigInt!

  # R signature value
  r: Bytes!

  # S signature value
  s: Bytes!
}

# AccessListEntry represents an access list entry
type AccessListEntry {
  address: Address!
  storageKeys: [Hash!]!
}

# Receipt represents a transaction receipt
type Receipt {
  # Transaction hash
  transactionHash: Hash!

  # Block number
  blockNumber: BigInt!

  # Block hash
  blockHash: Hash!

  # Transaction index
  transactionIndex: Int!

  # Contract address (for contract creation)
  contractAddress: Address

  # Gas used
  gasUsed: BigInt!

  # Cumulative gas used
  cumulativeGasUsed: BigInt!

  # Effective gas price
  effectiveGasPrice: BigInt!

  # Status (1 for success, 0 for failure)
  status: Int!

  # Logs
  logs: [Log!]!

  # Logs bloom filter
  logsBloom: Bytes!
}

# Log represents an event log
type Log {
  # Address that generated the log
  address: Address!

  # Topics
  topics: [Hash!]!

  # Data
  data: Bytes!

  # Block number
  blockNumber: BigInt!

  # Block hash
  blockHash: Hash!

  # Transaction hash
  transactionHash: Hash!

  # Transaction index
  transactionIndex: Int!

  # Log index
  logIndex: Int!

  # Removed (true if log was removed due to chain reorg)
  removed: Boolean!
}

# BalanceSnapshot represents an address balance at a specific block
type BalanceSnapshot {
  # Block number
  blockNumber: BigInt!

  # Account balance at this block
  balance: BigInt!

  # Change in balance (positive or negative)
  delta: BigInt!

  # Transaction that caused the balance change (may be null)
  transactionHash: Hash
}

# Filter input for querying blocks
input BlockFilter {
  # Filter by number range
  numberFrom: BigInt
  numberTo: BigInt

  # Filter by timestamp range
  timestampFrom: BigInt
  timestampTo: BigInt

  # Filter by miner address
  miner: Address
}

# Filter input for querying transactions
input TransactionFilter {
  # Filter by block number range
  blockNumberFrom: BigInt
  blockNumberTo: BigInt

  # Filter by from address
  from: Address

  # Filter by to address
  to: Address

  # Filter by transaction type
  type: Int
}

# Filter input for querying logs
input LogFilter {
  # Filter by address
  address: Address

  # Filter by topics
  topics: [Hash!]

  # Filter by block number range
  blockNumberFrom: BigInt
  blockNumberTo: BigInt
}

# Filter input for historical transaction queries
input HistoricalTransactionFilter {
  # Filter by block number range
  fromBlock: BigInt!
  toBlock: BigInt!

  # Filter by minimum value
  minValue: BigInt

  # Filter by maximum value
  maxValue: BigInt

  # Filter by transaction type (0=all, 1=sent, 2=received)
  txType: Int

  # Filter by success status only
  successOnly: Boolean
}

# Pagination input
input PaginationInput {
  # Number of items to return (default: 10, max: 100)
  limit: Int

  # Offset for pagination
  offset: Int
}

# Subscription root type for real-time updates
# All subscriptions support optional replayLast parameter to receive recent historical events
type Subscription {
  # Subscribe to new blocks as they are indexed
  # replayLast: Number of recent blocks to replay immediately upon subscription (max 100)
  newBlock(replayLast: Int): Block!

  # Subscribe to new transactions as they are indexed
  # replayLast: Number of recent transactions to replay immediately upon subscription (max 100)
  newTransaction(replayLast: Int): Transaction!

  # Subscribe to new pending transactions (if available)
  newPendingTransactions(limit: Int): Transaction!

  # Subscribe to new logs matching a filter
  # replayLast: Number of recent logs to replay immediately upon subscription (max 100)
  logs(filter: LogFilter!, replayLast: Int): Log!

  # Subscribe to system contract events
  # Filter by contract address to receive events only from specific contracts
  # replayLast: Number of recent events to replay immediately upon subscription (max 100)
  systemContractEvents(filter: SystemContractSubscriptionFilter, replayLast: Int): SystemContractEventMessage!

  # Subscribe to events from dynamically registered contracts
  # replayLast: Number of recent events to replay immediately upon subscription (max 100)
  dynamicContractEvents(filter: DynamicContractSubscriptionFilter, replayLast: Int): DynamicContractEvent!

  # Subscribe to new consensus block events with validator participation data
  # replayLast: Number of recent consensus blocks to replay immediately upon subscription (max 100)
  consensusBlock(replayLast: Int): ConsensusBlockSub!

  # Subscribe to chain fork detection events
  # replayLast: Number of recent fork events to replay immediately upon subscription (max 100)
  consensusFork(replayLast: Int): ConsensusForkSub!

  # Subscribe to validator set change events at epoch boundaries
  # replayLast: Number of recent validator changes to replay immediately upon subscription (max 100)
  consensusValidatorChange(replayLast: Int): ConsensusValidatorChangeSub!

  # Subscribe to consensus errors and anomalies (round changes, low participation)
  # replayLast: Number of recent errors to replay immediately upon subscription (max 100)
  consensusError(replayLast: Int): ConsensusErrorSub!
}

# Real-time consensus block data from subscription
type ConsensusBlockSub {
  # Block number
  blockNumber: BigInt!
  # Block hash
  blockHash: Hash!
  # Block timestamp
  timestamp: BigInt!
  # Consensus round number
  round: Int!
  # Previous round number
  prevRound: Int!
  # Whether round changed from 0
  roundChanged: Boolean!
  # Block proposer address
  proposer: Address!
  # Total number of validators
  validatorCount: Int!
  # Number of prepare signatures
  prepareCount: Int!
  # Number of commit signatures
  commitCount: Int!
  # Validator participation rate (0-100)
  participationRate: Float!
  # Rate of validators who missed commit (0-100)
  missedValidatorRate: Float!
  # Whether this block is at epoch boundary
  isEpochBoundary: Boolean!
  # Epoch number (only at epoch boundaries)
  epochNumber: BigInt
  # Validator addresses for the epoch (only at epoch boundaries)
  epochValidators: [Address!]
}

# Chain fork detection event from subscription
type ConsensusForkSub {
  # Block number where fork occurred
  forkBlockNumber: BigInt!
  # Hash of the fork block
  forkBlockHash: Hash!
  # Hash of chain 1 tip
  chain1Hash: Hash!
  # Height of chain 1
  chain1Height: BigInt!
  # Total weight/difficulty of chain 1
  chain1Weight: String!
  # Hash of chain 2 tip
  chain2Hash: Hash!
  # Height of chain 2
  chain2Height: BigInt!
  # Total weight/difficulty of chain 2
  chain2Weight: String!
  # Whether the fork has been resolved
  resolved: Boolean!
  # Winning chain (1 or 2, 0 if unresolved)
  winningChain: Int!
  # Unix timestamp when fork was detected
  detectedAt: BigInt!
  # Blocks between fork and detection
  detectionLag: BigInt!
}

# Validator set change event from subscription
type ConsensusValidatorChangeSub {
  # Block number where change occurred
  blockNumber: BigInt!
  # Block hash
  blockHash: Hash!
  # Block timestamp
  timestamp: BigInt!
  # Epoch number
  epochNumber: BigInt!
  # Whether this is an epoch boundary
  isEpochBoundary: Boolean!
  # Type of change: added, removed, replaced, reordered
  changeType: String!
  # Previous validator count
  previousValidatorCount: Int!
  # New validator count
  newValidatorCount: Int!
  # Addresses of added validators
  addedValidators: [Address!]
  # Addresses of removed validators
  removedValidators: [Address!]
  # Current validator set after change
  validatorSet: [Address!]
  # Additional information (JSON encoded)
  additionalInfo: String
}

# Consensus error or anomaly event from subscription
type ConsensusErrorSub {
  # Block number where error occurred
  blockNumber: BigInt!
  # Block hash
  blockHash: Hash!
  # Block timestamp
  timestamp: BigInt!
  # Error type: round_change, missed_validators, low_participation, etc.
  errorType: String!
  # Severity level: critical, high, medium, low
  severity: String!
  # Human-readable error message
  errorMessage: String!
  # Consensus round number
  round: Int!
  # Expected number of validators
  expectedValidators: Int!
  # Actual number of signers
  actualSigners: Int!
  # Current participation rate (0-100)
  participationRate: Float!
  # Whether consensus was impacted
  consensusImpacted: Boolean!
  # Blocks until recovery (0 if not applicable)
  recoveryTime: BigInt!
  # Addresses of validators who missed
  missedValidators: [Address!]
  # Additional error details (JSON encoded)
  errorDetails: String
}

# Filter for dynamic contract event subscription
input DynamicContractSubscriptionFilter {
  # Filter by contract address
  contract: Address

  # Filter by event names
  eventNames: [String!]
}

# Filter for system contract event subscription
input SystemContractSubscriptionFilter {
  # Filter by contract address (optional, receives all if not specified)
  contract: Address

  # Filter by specific event types (optional, receives all if not specified)
  eventTypes: [String!]
}

# Real-time system contract event message
type SystemContractEventMessage {
  # Contract address that emitted the event
  contract: Address!

  # Event name (e.g., "Mint", "Burn", "ProposalCreated")
  eventName: String!

  # Block number
  blockNumber: BigInt!

  # Transaction hash
  transactionHash: Hash!

  # Log index in the transaction
  logIndex: Int!

  # Event-specific data as JSON string
  data: String!

  # Timestamp when the event was detected
  timestamp: BigInt!
}

# Query root type
type Query {
  # Get the latest indexed block height
  latestHeight: BigInt!

  # Get a block by number
  block(number: BigInt!): Block

  # Get a block by hash
  blockByHash(hash: Hash!): Block

  # Get blocks with optional filtering and pagination
  blocks(filter: BlockFilter, pagination: PaginationInput): BlockConnection!

  # Get blocks in a specific range (optimized for frontend catch-up)
  # Returns blocks from startNumber to endNumber (inclusive)
  # Maximum range is 100 blocks per request
  blocksRange(
    startNumber: BigInt!
    endNumber: BigInt!
    includeTransactions: Boolean
    includeReceipts: Boolean
  ): BlockRangeResult!

  # Get a transaction by hash
  transaction(hash: Hash!): Transaction

  # Get transactions with optional filtering and pagination
  transactions(filter: TransactionFilter, pagination: PaginationInput): TransactionConnection!

  # Get transactions by address (sent from or received by)
  transactionsByAddress(address: Address!, pagination: PaginationInput): TransactionConnection!

  # Get a receipt by transaction hash
  receipt(transactionHash: Hash!): Receipt

  # Get receipts for a block
  receiptsByBlock(blockNumber: BigInt!): [Receipt!]!

  # Get logs with filtering
  logs(filter: LogFilter!, pagination: PaginationInput): LogConnection!

  # ========== Historical Data Queries ==========

  # Get blocks within a time range
  blocksByTimeRange(
    fromTime: BigInt!
    toTime: BigInt!
    pagination: PaginationInput
  ): BlockConnection!

  # Get the block closest to a specific timestamp
  blockByTimestamp(timestamp: BigInt!): Block

  # Get filtered transactions for an address with advanced filtering
  transactionsByAddressFiltered(
    address: Address!
    filter: HistoricalTransactionFilter!
    pagination: PaginationInput
  ): TransactionConnection!

  # Get address balance at a specific block (0 for latest)
  addressBalance(
    address: Address!
    blockNumber: BigInt
  ): BigInt!

  # Get balance history for an address
  balanceHistory(
    address: Address!
    fromBlock: BigInt!
    toBlock: BigInt!
    pagination: PaginationInput
  ): BalanceHistoryConnection!

  # Get total number of indexed blocks
  blockCount: BigInt!

  # Get total number of indexed transactions
  transactionCount: BigInt!

  # ========== Analytics Queries ==========

  # Get top miners by block count
  topMiners(
    limit: Int
    fromBlock: BigInt
    toBlock: BigInt
  ): [MinerStats!]!

  # Get token balances for an address (ERC-20/721/1155)
  tokenBalances(
    address: Address!
    tokenType: String
  ): [TokenBalance!]!

  # ========== System Contract Queries ==========

  # Get current total supply of native coin
  totalSupply: BigInt!

  # Get mint events
  mintEvents(
    filter: SystemContractEventFilter!
    pagination: PaginationInput
  ): MintEventConnection!

  # Get burn events
  burnEvents(
    filter: SystemContractEventFilter!
    pagination: PaginationInput
  ): BurnEventConnection!

  # Get list of active minters
  activeMinters: [MinterInfo!]!

  # Get minter allowance for a specific minter
  minterAllowance(minter: Address!): BigInt!

  # Get minter configuration history
  minterHistory(minter: Address!): [MinterConfigEvent!]!

  # Get list of active validators
  activeValidators: [ValidatorInfo!]!

  # Get validator change history
  validatorHistory(
    validator: Address!
  ): [ValidatorChangeEvent!]!

  # Get gas tip update history
  gasTipHistory(
    filter: SystemContractEventFilter!
  ): [GasTipUpdateEvent!]!

  # Get list of blacklisted addresses
  blacklistedAddresses: [Address!]!

  # Get blacklist event history for an address
  blacklistHistory(
    address: Address!
  ): [BlacklistEvent!]!

  # Get governance proposals
  proposals(
    filter: ProposalFilter!
    pagination: PaginationInput
  ): ProposalConnection!

  # Get a specific proposal by ID
  proposal(
    contract: Address!
    proposalId: BigInt!
  ): Proposal

  # Get votes for a specific proposal
  proposalVotes(
    contract: Address!
    proposalId: BigInt!
  ): [ProposalVote!]!

  # Get member change history for a contract
  memberHistory(
    contract: Address!
  ): [MemberChangeEvent!]!

  # Get emergency pause event history for a contract
  emergencyPauseHistory(
    contract: Address!
  ): [EmergencyPauseEvent!]!

  # Get deposit mint proposals
  depositMintProposals(
    filter: SystemContractEventFilter!
    status: ProposalStatus
  ): [DepositMintProposal!]!

  # Get max proposals per member update history
  maxProposalsUpdateHistory(
    contract: Address!
  ): [MaxProposalsUpdateEvent!]!

  # Get proposal execution skipped events
  proposalExecutionSkippedEvents(
    contract: Address!
    proposalId: BigInt
  ): [ProposalExecutionSkippedEvent!]!

  # ========== WBFT Consensus Queries ==========

  # Get WBFT consensus metadata for a block by number
  wbftBlockExtra(blockNumber: BigInt!): WBFTBlockExtra

  # Get WBFT consensus metadata for a block by hash
  wbftBlockExtraByHash(blockHash: Hash!): WBFTBlockExtra

  # Get epoch information for a specific epoch
  epochInfo(epochNumber: BigInt!): EpochInfo

  # Get the most recent epoch information
  latestEpochInfo: EpochInfo

  # Get signing statistics for a specific validator
  validatorSigningStats(
    validatorAddress: Address!
    fromBlock: BigInt!
    toBlock: BigInt!
  ): ValidatorSigningStats

  # Get signing statistics for all validators in a block range
  allValidatorsSigningStats(
    fromBlock: BigInt!
    toBlock: BigInt!
    pagination: PaginationInput
  ): ValidatorSigningStatsConnection!

  # Get detailed signing activity for a specific validator
  validatorSigningActivity(
    validatorAddress: Address!
    fromBlock: BigInt!
    toBlock: BigInt!
    pagination: PaginationInput
  ): ValidatorSigningActivityConnection!

  # Get list of validators who signed a specific block
  blockSigners(blockNumber: BigInt!): BlockSigners

  # ========== Address Indexing Queries ==========

  # Get contract creation information by contract address
  contractCreation(address: Address!): ContractCreation

  # Get contract verification information by contract address
  contractVerification(address: Address!): ContractVerification

  # Get contracts created by a specific address
  contractsByCreator(
    creator: Address!
    pagination: PaginationInput
  ): ContractCreationConnection!

  # Get internal transactions for a transaction hash
  internalTransactions(txHash: Hash!): [InternalTransaction!]!

  # Get internal transactions involving a specific address
  internalTransactionsByAddress(
    address: Address!
    isFrom: Boolean!
    pagination: PaginationInput
  ): InternalTransactionConnection!

  # Get ERC20 transfer by transaction hash and log index
  erc20Transfer(txHash: Hash!, logIndex: Int!): ERC20Transfer

  # Get ERC20 transfers for a specific token contract
  erc20TransfersByToken(
    token: Address!
    pagination: PaginationInput
  ): ERC20TransferConnection!

  # Get ERC20 transfers involving a specific address
  erc20TransfersByAddress(
    address: Address!
    isFrom: Boolean!
    pagination: PaginationInput
  ): ERC20TransferConnection!

  # Get ERC721 transfer by transaction hash and log index
  erc721Transfer(txHash: Hash!, logIndex: Int!): ERC721Transfer

  # Get ERC721 transfers for a specific NFT contract
  erc721TransfersByToken(
    token: Address!
    pagination: PaginationInput
  ): ERC721TransferConnection!

  # Get ERC721 transfers involving a specific address
  erc721TransfersByAddress(
    address: Address!
    isFrom: Boolean!
    pagination: PaginationInput
  ): ERC721TransferConnection!

  # Get current owner of an NFT token
  erc721Owner(token: Address!, tokenId: BigInt!): Address

  # ========== Dynamic Contract Queries ==========

  # Get a registered contract by address
  registeredContract(address: Address!): RegisteredContract

  # Get all registered contracts
  registeredContracts: [RegisteredContract!]!

  # Get events from a registered contract
  dynamicContractEvents(
    filter: DynamicContractEventFilter!
    pagination: PaginationInput
  ): [DynamicContractEvent!]!

  # ========== RPC Proxy Queries (Real-time Chain Data) ==========

  # Get live balance directly from chain RPC (real-time, not from indexed storage)
  liveBalance(
    address: Address!
    blockNumber: BigInt
  ): LiveBalanceResult!

  # Execute a read-only contract call via RPC proxy
  contractCall(
    address: Address!
    method: String!
    params: String
    abi: String
  ): ContractCallResult!

  # Get real-time transaction status from chain
  transactionStatus(txHash: Hash!): TransactionStatusResult!

  # Get internal transactions using debug_traceTransaction RPC
  internalTransactionsRPC(txHash: Hash!): InternalTransactionsRPCResult!

  # Get RPC proxy service metrics
  rpcProxyMetrics: RPCProxyMetrics!

  # ========== Fee Delegation Queries ==========

  # Get overall fee delegation statistics
  feeDelegationStats(
    fromBlock: BigInt
    toBlock: BigInt
  ): FeeDelegationStats!

  # Get top fee payers by transaction count
  topFeePayers(
    limit: Int
    fromBlock: BigInt
    toBlock: BigInt
  ): TopFeePayersResult!

  # Get statistics for a specific fee payer
  feePayerStats(
    address: Address!
    fromBlock: BigInt
    toBlock: BigInt
  ): FeePayerStats!
}

# Block connection for pagination
type BlockConnection {
  # List of blocks
  nodes: [Block!]!

  # Total count
  totalCount: Int!

  # Page info
  pageInfo: PageInfo!
}

# Block range result for efficient bulk data transfer
# Used for frontend catch-up scenarios
type BlockRangeResult {
  # List of blocks in the range
  blocks: [Block!]!

  # Start block number in the result
  startNumber: BigInt!

  # End block number in the result
  endNumber: BigInt!

  # Number of blocks returned
  count: Int!

  # Whether there are more blocks after endNumber
  hasMore: Boolean!

  # Latest known block height (for sync status)
  latestHeight: BigInt!
}

# Transaction connection for pagination
type TransactionConnection {
  # List of transactions
  nodes: [Transaction!]!

  # Total count
  totalCount: Int!

  # Page info
  pageInfo: PageInfo!
}

# Log connection for pagination
type LogConnection {
  # List of logs
  nodes: [Log!]!

  # Total count
  totalCount: Int!

  # Page info
  pageInfo: PageInfo!
}

# Page info for pagination
type PageInfo {
  # Has next page
  hasNextPage: Boolean!

  # Has previous page
  hasPreviousPage: Boolean!

  # Start cursor
  startCursor: String

  # End cursor
  endCursor: String
}

# Balance history connection for pagination
type BalanceHistoryConnection {
  # List of balance snapshots
  nodes: [BalanceSnapshot!]!

  # Total count
  totalCount: Int!

  # Page info
  pageInfo: PageInfo!
}

# MinerStats represents mining statistics for a miner address
type MinerStats {
  # Miner address
  address: Address!

  # Number of blocks mined
  blockCount: BigInt!

  # Most recent block mined
  lastBlockNumber: BigInt!

  # Timestamp of last block mined
  lastBlockTime: BigInt!

  # Percentage of total blocks mined
  percentage: Float!

  # Total rewards earned (in Wei)
  totalRewards: BigInt!
}

# TokenBalance represents a token balance for an address
type TokenBalance {
  # Token contract address
  contractAddress: Address!

  # Token standard (ERC20, ERC721, ERC1155)
  tokenType: String!

  # Token balance
  balance: BigInt!

  # Token ID (for ERC721/ERC1155, null for ERC20)
  tokenId: BigInt

  # Token name
  name: String

  # Token symbol
  symbol: String

  # Token decimals (ERC20 only)
  decimals: Int

  # Token metadata (JSON string, for NFTs)
  metadata: String
}

# ========== System Contract Types ==========

# ProposalStatus enum
enum ProposalStatus {
  NONE
  VOTING
  APPROVED
  EXECUTED
  CANCELLED
  EXPIRED
  FAILED
  REJECTED
}

# MintEvent represents a mint event from NativeCoinAdapter
type MintEvent {
  # Block number
  blockNumber: BigInt!

  # Transaction hash
  transactionHash: Hash!

  # Minter address
  minter: Address!

  # Recipient address
  to: Address!

  # Mint amount
  amount: BigInt!

  # Timestamp
  timestamp: BigInt!
}

# BurnEvent represents a burn event
type BurnEvent {
  # Block number
  blockNumber: BigInt!

  # Transaction hash
  transactionHash: Hash!

  # Burner address
  burner: Address!

  # Burn amount
  amount: BigInt!

  # Timestamp
  timestamp: BigInt!

  # Withdrawal ID (for GovMinter)
  withdrawalId: String
}

# MinterConfigEvent represents minter configuration changes
type MinterConfigEvent {
  # Block number
  blockNumber: BigInt!

  # Transaction hash
  transactionHash: Hash!

  # Minter address
  minter: Address!

  # Minter allowance
  allowance: BigInt!

  # Action (configured or removed)
  action: String!

  # Timestamp
  timestamp: BigInt!
}

# Proposal represents a governance proposal
type Proposal {
  # Contract address
  contract: Address!

  # Proposal ID
  proposalId: BigInt!

  # Proposer address
  proposer: Address!

  # Action type
  actionType: Bytes!

  # Call data
  callData: Bytes!

  # Member version
  memberVersion: BigInt!

  # Required approvals
  requiredApprovals: Int!

  # Approved count
  approved: Int!

  # Rejected count
  rejected: Int!

  # Proposal status
  status: ProposalStatus!

  # Created timestamp
  createdAt: BigInt!

  # Executed timestamp (null if not executed)
  executedAt: BigInt

  # Block number
  blockNumber: BigInt!

  # Transaction hash
  transactionHash: Hash!
}

# ProposalVote represents a vote on a proposal
type ProposalVote {
  # Contract address
  contract: Address!

  # Proposal ID
  proposalId: BigInt!

  # Voter address
  voter: Address!

  # Approval (true for approve, false for reject)
  approval: Boolean!

  # Block number
  blockNumber: BigInt!

  # Transaction hash
  transactionHash: Hash!

  # Timestamp
  timestamp: BigInt!
}

# GasTipUpdateEvent represents a gas tip update
type GasTipUpdateEvent {
  # Block number
  blockNumber: BigInt!

  # Transaction hash
  transactionHash: Hash!

  # Old tip value
  oldTip: BigInt!

  # New tip value
  newTip: BigInt!

  # Updater address
  updater: Address!

  # Timestamp
  timestamp: BigInt!
}

# BlacklistEvent represents blacklist changes
type BlacklistEvent {
  # Block number
  blockNumber: BigInt!

  # Transaction hash
  transactionHash: Hash!

  # Account address
  account: Address!

  # Action (blacklisted or unblacklisted)
  action: String!

  # Proposal ID
  proposalId: BigInt

  # Timestamp
  timestamp: BigInt!
}

# ValidatorChangeEvent represents validator changes
type ValidatorChangeEvent {
  # Block number
  blockNumber: BigInt!

  # Transaction hash
  transactionHash: Hash!

  # Validator address
  validator: Address!

  # Action (added, removed, changed)
  action: String!

  # Old validator address (for changed action)
  oldValidator: Address

  # Timestamp
  timestamp: BigInt!
}

# MemberChangeEvent represents member changes in Gov contracts
type MemberChangeEvent {
  # Contract address
  contract: Address!

  # Block number
  blockNumber: BigInt!

  # Transaction hash
  transactionHash: Hash!

  # Member address
  member: Address!

  # Action (added, removed, changed)
  action: String!

  # Old member address (for changed action)
  oldMember: Address

  # Total members count
  totalMembers: BigInt!

  # New quorum value
  newQuorum: Int!

  # Timestamp
  timestamp: BigInt!
}

# EmergencyPauseEvent represents emergency pause/unpause events
type EmergencyPauseEvent {
  # Contract address
  contract: Address!

  # Block number
  blockNumber: BigInt!

  # Transaction hash
  transactionHash: Hash!

  # Proposal ID
  proposalId: BigInt

  # Action (paused or unpaused)
  action: String!

  # Timestamp
  timestamp: BigInt!
}

# MaxProposalsUpdateEvent represents max proposals per member update from GovBase
type MaxProposalsUpdateEvent {
  # Contract address
  contract: Address!

  # Block number
  blockNumber: BigInt!

  # Transaction hash
  transactionHash: Hash!

  # Old maximum proposals per member
  oldMax: BigInt!

  # New maximum proposals per member
  newMax: BigInt!

  # Timestamp
  timestamp: BigInt!
}

# ProposalExecutionSkippedEvent represents skipped proposal execution from GovCouncil
type ProposalExecutionSkippedEvent {
  # Contract address
  contract: Address!

  # Block number
  blockNumber: BigInt!

  # Transaction hash
  transactionHash: Hash!

  # Account address related to the skipped execution
  account: Address!

  # Proposal ID
  proposalId: BigInt!

  # Reason for skipping (e.g., ALREADY_BLACKLISTED, NOT_IN_BLACKLIST)
  reason: String!

  # Timestamp
  timestamp: BigInt!
}

# DepositMintProposal represents a deposit mint proposal from GovMinter
type DepositMintProposal {
  # Proposal ID
  proposalId: BigInt!

  # Requester address (member who proposed the mint)
  requester: Address!

  # Beneficiary address (recipient of minted tokens)
  beneficiary: Address!

  # Mint amount
  amount: BigInt!

  # Deposit ID (may be empty as indexed string is hashed)
  depositId: String!

  # Bank reference number
  bankReference: String!

  # Proposal status
  status: ProposalStatus!

  # Block number
  blockNumber: BigInt!

  # Transaction hash
  transactionHash: Hash!

  # Timestamp
  timestamp: BigInt!
}

# MinterInfo represents information about a minter
type MinterInfo {
  # Minter address
  address: Address!

  # Current allowance
  allowance: BigInt!

  # Is currently active
  isActive: Boolean!
}

# ValidatorInfo represents information about a validator
type ValidatorInfo {
  # Validator address
  address: Address!

  # Is currently active
  isActive: Boolean!
}

# Connections for pagination
type MintEventConnection {
  nodes: [MintEvent!]!
  totalCount: Int!
  pageInfo: PageInfo!
}

type BurnEventConnection {
  nodes: [BurnEvent!]!
  totalCount: Int!
  pageInfo: PageInfo!
}

type ProposalConnection {
  nodes: [Proposal!]!
  totalCount: Int!
  pageInfo: PageInfo!
}

type ProposalVoteConnection {
  nodes: [ProposalVote!]!
  totalCount: Int!
  pageInfo: PageInfo!
}

# Filter inputs for system contracts
input SystemContractEventFilter {
  # Filter by block number range
  fromBlock: BigInt!
  toBlock: BigInt!

  # Filter by specific address (minter, burner, validator, etc.)
  address: Address
}

input ProposalFilter {
  # Filter by contract address
  contract: Address!

  # Filter by status
  status: ProposalStatus

  # Filter by proposer
  proposer: Address
}

# ========== WBFT Consensus Types ==========

# WBFTAggregatedSeal represents an aggregated BLS signature from validators
type WBFTAggregatedSeal {
  # Bitmap of validators who signed
  sealers: Bytes!

  # Aggregated BLS signature (96 bytes)
  signature: Bytes!
}

# Candidate represents a validator candidate
type Candidate {
  # Validator address
  address: Address!

  # Diligence score (unit: 10^-6)
  diligence: BigInt!
}

# EpochInfo represents validator set information for an epoch
type EpochInfo {
  # Epoch number
  epochNumber: BigInt!

  # Block number where epoch info is stored
  blockNumber: BigInt!

  # Candidate list for next epoch
  candidates: [Candidate!]!

  # Validator indices for next epoch
  validators: [Int!]!

  # BLS public keys for next epoch
  blsPublicKeys: [Bytes!]!
}

# WBFTBlockExtra represents WBFT consensus metadata for a block
type WBFTBlockExtra {
  # Block number
  blockNumber: BigInt!

  # Block hash
  blockHash: Hash!

  # BLS signature of block number
  randaoReveal: Bytes!

  # Previous block's round number
  prevRound: Int!

  # Previous block's prepare seal
  prevPreparedSeal: WBFTAggregatedSeal

  # Previous block's commit seal
  prevCommittedSeal: WBFTAggregatedSeal

  # Current round number
  round: Int!

  # Prepare phase aggregated seal
  preparedSeal: WBFTAggregatedSeal

  # Commit phase aggregated seal
  committedSeal: WBFTAggregatedSeal

  # Gas tip value agreed through governance
  gasTip: BigInt

  # Epoch info (only for last block of epoch)
  epochInfo: EpochInfo

  # Block timestamp
  timestamp: BigInt!
}

# ValidatorSigningStats represents signing statistics for a validator
type ValidatorSigningStats {
  # Validator address
  validatorAddress: Address!

  # Validator index
  validatorIndex: Int!

  # Total number of prepare signatures
  prepareSignCount: BigInt!

  # Total number of missed prepare signatures
  prepareMissCount: BigInt!

  # Total number of commit signatures
  commitSignCount: BigInt!

  # Total number of missed commit signatures
  commitMissCount: BigInt!

  # Block range start
  fromBlock: BigInt!

  # Block range end
  toBlock: BigInt!

  # Signing rate percentage
  signingRate: Float!
}

# ValidatorSigningActivity represents a validator's signing activity for a specific block
type ValidatorSigningActivity {
  # Block number
  blockNumber: BigInt!

  # Block hash
  blockHash: Hash!

  # Validator address
  validatorAddress: Address!

  # Validator index
  validatorIndex: Int!

  # Whether validator signed in prepare phase
  signedPrepare: Boolean!

  # Whether validator signed in commit phase
  signedCommit: Boolean!

  # Round number
  round: Int!

  # Block timestamp
  timestamp: BigInt!
}

# BlockSigners represents validators who signed a specific block
type BlockSigners {
  # Block number
  blockNumber: BigInt!

  # Validators who signed in prepare phase
  preparers: [Address!]!

  # Validators who signed in commit phase
  committers: [Address!]!
}

# Connections for pagination
type ValidatorSigningStatsConnection {
  nodes: [ValidatorSigningStats!]!
  totalCount: Int!
  pageInfo: PageInfo!
}

type ValidatorSigningActivityConnection {
  nodes: [ValidatorSigningActivity!]!
  totalCount: Int!
  pageInfo: PageInfo!
}

# ========== Enhanced Consensus Types ==========

# ConsensusData represents complete consensus information for a block
type ConsensusData {
  # Block identification
  blockNumber: BigInt!
  blockHash: Hash!

  # Round information
  round: Int!
  prevRound: Int!
  roundChanged: Boolean!

  # Validator participation
  proposer: Address!
  validators: [Address!]!
  prepareSigners: [Address!]!
  commitSigners: [Address!]!

  # Participation metrics
  prepareCount: Int!
  commitCount: Int!
  missedPrepare: [Address!]!
  missedCommit: [Address!]!

  # Additional data
  vanityData: Bytes
  randaoReveal: Bytes
  gasTip: BigInt

  # Epoch information
  epochInfo: EpochData
  isEpochBoundary: Boolean!

  # Metadata
  timestamp: BigInt!

  # Calculated metrics
  participationRate: Float!
  isHealthy: Boolean!
}

# EpochData represents enhanced epoch information
type EpochData {
  # Epoch number
  epochNumber: BigInt!

  # Validator and candidate counts
  validatorCount: Int!
  candidateCount: Int!

  # Validators in this epoch
  validators: [ValidatorInfoDetailed!]!

  # Candidates for next epoch
  candidates: [CandidateInfo!]!
}

# ValidatorInfoDetailed represents detailed validator information
type ValidatorInfoDetailed {
  # Validator address
  address: Address!

  # Validator index in the set
  index: Int!

  # BLS public key
  blsPubKey: Bytes
}

# CandidateInfo represents a validator candidate
type CandidateInfo {
  # Candidate address
  address: Address!

  # Diligence score (0-2,000,000)
  diligence: BigInt!
}

# ValidatorStats represents enhanced validator statistics
type ValidatorStats {
  # Validator address
  address: Address!

  # Block production
  totalBlocks: BigInt!
  blocksProposed: BigInt!

  # Participation metrics
  preparesSigned: BigInt!
  commitsSigned: BigInt!
  preparesMissed: BigInt!
  commitsMissed: BigInt!
  participationRate: Float!

  # Recent activity tracking
  lastProposedBlock: BigInt
  lastCommittedBlock: BigInt
  lastSeenBlock: BigInt
}

# ValidatorParticipation provides detailed participation data over a range
type ValidatorParticipation {
  # Validator address
  address: Address!

  # Block range
  startBlock: BigInt!
  endBlock: BigInt!

  # Aggregated statistics
  totalBlocks: BigInt!
  blocksProposed: BigInt!
  blocksCommitted: BigInt!
  blocksMissed: BigInt!
  participationRate: Float!

  # Per-block breakdown
  blocks: [BlockParticipation!]!
}

# BlockParticipation represents a validator's participation in a specific block
type BlockParticipation {
  blockNumber: BigInt!
  wasProposer: Boolean!
  signedPrepare: Boolean!
  signedCommit: Boolean!
  round: Int!
}

# RoundAnalysis provides statistical analysis of round changes
type RoundAnalysis {
  # Block range
  startBlock: BigInt!
  endBlock: BigInt!

  # Statistics
  totalBlocks: BigInt!
  blocksWithRoundChange: BigInt!
  roundChangeRate: Float!
  averageRound: Float!
  maxRound: Int!

  # Round distribution
  roundDistribution: [RoundDistribution!]!
}

# RoundDistribution shows the distribution of blocks by round number
type RoundDistribution {
  round: Int!
  count: BigInt!
  percentage: Float!
}

# ValidatorSet represents the active validator set at a specific point
type ValidatorSet {
  blockNumber: BigInt!
  epochNumber: BigInt
  validators: [Address!]!
  count: Int!
}

# ValidatorActivity tracks real-time validator activity
type ValidatorActivity {
  address: Address!
  isActive: Boolean!
  isOnline: Boolean!
  lastSeen: BigInt!
  blocksAgo: BigInt!
  currentStreak: BigInt!
}

# ValidatorChange represents a change in validator set at epoch boundary
type ValidatorChange {
  epochNumber: BigInt!
  blockNumber: BigInt!
  previousValidators: [Address!]!
  newValidators: [Address!]!
  addedValidators: [Address!]!
  removedValidators: [Address!]!
}

# ========== Address Indexing Types ==========

# ContractCreation represents a contract creation event
type ContractCreation {
  # Created contract address
  contractAddress: Address!

  # Creator address
  creator: Address!

  # Transaction hash that created the contract
  transactionHash: Hash!

  # Block number
  blockNumber: BigInt!

  # Timestamp
  timestamp: BigInt!

  # Deployed bytecode size
  bytecodeSize: Int!
}

# ContractVerification represents verified contract source code
type ContractVerification {
  # Contract address
  address: Address!

  # Whether the contract is verified
  isVerified: Boolean!

  # Contract name
  name: String

  # Solidity compiler version (e.g., "0.8.20")
  compilerVersion: String

  # Whether optimization was enabled during compilation
  optimizationEnabled: Boolean

  # Number of optimization runs
  optimizationRuns: Int

  # Verified source code
  sourceCode: String

  # Contract ABI (JSON string)
  abi: String

  # Constructor arguments (encoded)
  constructorArguments: String

  # Verification timestamp
  verifiedAt: String

  # License type (e.g., "MIT", "GPL-3.0")
  licenseType: String
}

# InternalTransaction represents an internal call during transaction execution
type InternalTransaction {
  # Original transaction hash
  transactionHash: Hash!

  # Block number
  blockNumber: BigInt!

  # Order index
  index: Int!

  # Type: CALL, DELEGATECALL, STATICCALL, CREATE, etc.
  type: String!

  # Caller address
  from: Address!

  # Callee address (or created address for CREATE)
  to: Address!

  # Transferred ETH amount (wei)
  value: BigInt!

  # Allocated gas
  gas: BigInt!

  # Used gas
  gasUsed: BigInt!

  # Call data
  input: Bytes!

  # Return data
  output: Bytes!

  # Error message (if failed)
  error: String

  # Call depth (0 = root)
  depth: Int!
}

# ERC20Transfer represents an ERC20 token transfer
type ERC20Transfer {
  # Token contract address
  contractAddress: Address!

  # Sender address
  from: Address!

  # Recipient address
  to: Address!

  # Transfer amount
  value: BigInt!

  # Transaction hash
  transactionHash: Hash!

  # Block number
  blockNumber: BigInt!

  # Log index
  logIndex: Int!

  # Timestamp
  timestamp: BigInt!
}

# ERC721Transfer represents an ERC721 NFT transfer
type ERC721Transfer {
  # NFT contract address
  contractAddress: Address!

  # Sender address
  from: Address!

  # Recipient address
  to: Address!

  # Token ID
  tokenId: BigInt!

  # Transaction hash
  transactionHash: Hash!

  # Block number
  blockNumber: BigInt!

  # Log index
  logIndex: Int!

  # Timestamp
  timestamp: BigInt!
}

# Connections for address indexing pagination
type ContractCreationConnection {
  nodes: [ContractCreation!]!
  totalCount: Int!
  pageInfo: PageInfo!
}

type InternalTransactionConnection {
  nodes: [InternalTransaction!]!
  totalCount: Int!
  pageInfo: PageInfo!
}

type ERC20TransferConnection {
  nodes: [ERC20Transfer!]!
  totalCount: Int!
  pageInfo: PageInfo!
}

type ERC721TransferConnection {
  nodes: [ERC721Transfer!]!
  totalCount: Int!
  pageInfo: PageInfo!
}

# Registered Contract for dynamic event parsing
type RegisteredContract {
  # Contract address
  address: Address!

  # Contract name
  name: String!

  # Contract ABI (JSON string)
  abi: String!

  # Registration timestamp
  registeredAt: BigInt!

  # Block number when registered
  blockNumber: BigInt!

  # Whether the contract is verified
  isVerified: Boolean!

  # List of event names in the ABI
  events: [String!]!
}

# Input for registering a contract
input RegisterContractInput {
  # Contract address
  address: Address!

  # Human-readable contract name
  name: String!

  # Contract ABI JSON string
  abi: String!

  # Block number to start parsing from
  blockNumber: BigInt
}

# Dynamic contract event
type DynamicContractEvent {
  # Contract address
  contract: Address!

  # Contract name
  contractName: String!

  # Event name
  eventName: String!

  # Block number
  blockNumber: BigInt!

  # Transaction hash
  txHash: Hash!

  # Log index
  logIndex: Int!

  # Event data as JSON string
  data: String!

  # Timestamp
  timestamp: BigInt!
}

# Filter for dynamic contract events
input DynamicContractEventFilter {
  # Filter by contract address
  contract: Address

  # Filter by event names
  eventNames: [String!]

  # Filter by block range
  fromBlock: BigInt
  toBlock: BigInt
}

# ========== RPC Proxy Types ==========

# Live balance result from chain RPC
type LiveBalanceResult {
  # Account address
  address: Address!
  # Account balance in wei
  balance: BigInt!
  # Block number at which balance was queried
  blockNumber: BigInt!
}

# Contract call result
type ContractCallResult {
  # Decoded result (if ABI available)
  result: String
  # Raw hex result
  rawResult: String!
  # Whether the result was successfully decoded
  decoded: Boolean!
}

# Transaction status result
type TransactionStatusResult {
  # Transaction hash
  txHash: Hash!
  # Current status (pending, success, failed, not_found, confirmed)
  status: String!
  # Block number (if mined)
  blockNumber: BigInt
  # Block hash (if mined)
  blockHash: Hash
  # Number of confirmations
  confirmations: BigInt!
  # Gas used (if mined)
  gasUsed: BigInt
}

# Internal transactions result from RPC
type InternalTransactionsRPCResult {
  # Transaction hash
  txHash: Hash!
  # List of internal transactions
  internalTransactions: [InternalTransactionRPC!]!
  # Total count
  totalCount: Int!
}

# Internal transaction from RPC trace
type InternalTransactionRPC {
  # Call type (CALL, CREATE, DELEGATECALL, etc.)
  type: String!
  # From address
  from: Address!
  # To address
  to: Address!
  # Value transferred
  value: BigInt!
  # Gas provided
  gas: BigInt!
  # Gas used
  gasUsed: BigInt!
  # Input data
  input: String!
  # Output data
  output: String!
  # Error message if failed
  error: String
  # Call depth
  depth: Int!
  # Trace address (path in call tree)
  traceAddress: [Int!]!
}

# RPC Proxy service metrics
type RPCProxyMetrics {
  # Total number of requests processed
  totalRequests: BigInt!
  # Number of successful requests
  successfulRequests: BigInt!
  # Number of failed requests
  failedRequests: BigInt!
  # Number of cache hits
  cacheHits: BigInt!
  # Number of cache misses
  cacheMisses: BigInt!
  # Average response latency in milliseconds
  averageLatency: BigInt!
  # Current request queue depth
  queueDepth: Int!
  # Number of active workers
  activeWorkers: Int!
  # Circuit breaker state (closed, open, half-open)
  circuitState: String!
}

# ========== Fee Delegation Types ==========

# Overall fee delegation statistics
type FeeDelegationStats {
  # Total number of fee delegation transactions
  totalFeeDelegatedTxs: BigInt!
  # Total fees saved by users (paid by fee payers) in wei
  totalFeesSaved: BigInt!
  # Percentage of fee delegation transactions vs total transactions
  adoptionRate: Float!
  # Average fee saved per fee delegation transaction in wei
  avgFeeSaved: BigInt!
}

# Statistics for a single fee payer
type FeePayerStats {
  # Fee payer address
  address: Address!
  # Number of transactions sponsored by this fee payer
  txCount: BigInt!
  # Total fees paid by this fee payer in wei
  totalFeesPaid: BigInt!
  # Percentage of total fee delegation transactions
  percentage: Float!
}

# Top fee payers result with pagination info
type TopFeePayersResult {
  # List of fee payer statistics
  nodes: [FeePayerStats!]!
  # Total count of unique fee payers
  totalCount: BigInt!
}

# Mutation type for write operations
type Mutation {
  # Verify a contract's source code
  verifyContract(
    address: Address!
    sourceCode: String!
    compilerVersion: String!
    optimizationEnabled: Boolean!
    optimizationRuns: Int
    constructorArguments: String
    contractName: String
    licenseType: String
  ): ContractVerification!

  # Register a contract for dynamic event parsing
  registerContract(input: RegisterContractInput!): RegisteredContract!

  # Unregister a contract from dynamic event parsing
  unregisterContract(address: Address!): Boolean!
}
