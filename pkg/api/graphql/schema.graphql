# GraphQL Schema for Ethereum Blockchain Indexer

# Scalar types for Ethereum data
# Bytes represents hex-encoded bytes (0x...)
scalar Bytes

# BigInt represents large integers as strings
scalar BigInt

# Address represents an Ethereum address (0x...)
scalar Address

# Hash represents a 32-byte hash (0x...)
scalar Hash

# DateTime represents a timestamp in RFC3339 format
scalar DateTime

# JSON represents arbitrary JSON data
scalar JSON

# ========== Multi-Chain Types ==========

# ChainStatus represents the status of a chain instance
enum ChainStatus {
  REGISTERED
  STARTING
  SYNCING
  ACTIVE
  STOPPING
  STOPPED
  ERROR
}

# Chain represents a blockchain instance managed by the indexer
type Chain {
  # Unique chain identifier
  id: ID!

  # Human-readable chain name
  name: String!

  # Chain ID (EVM chain ID)
  chainId: BigInt!

  # RPC endpoint URL
  rpcEndpoint: String!

  # WebSocket endpoint URL (optional)
  wsEndpoint: String

  # Adapter type (auto, evm, stableone, anvil)
  adapterType: String!

  # Current chain status
  status: ChainStatus!

  # Sync progress information
  syncProgress: SyncProgress

  # Health check status
  health: HealthStatus

  # Whether the chain is enabled
  enabled: Boolean!

  # Latest indexed block height
  latestHeight: BigInt

  # Start block height for indexing
  startHeight: BigInt!

  # Registration timestamp
  registeredAt: DateTime!
}

# SyncProgress represents the synchronization progress of a chain
type SyncProgress {
  # Current indexed block height
  currentBlock: BigInt!

  # Target block height (latest on chain)
  targetBlock: BigInt!

  # Sync progress percentage (0-100)
  percentage: Float!

  # Estimated time to sync completion in seconds
  estimatedTimeRemaining: BigInt

  # Blocks per second sync rate
  blocksPerSecond: Float!

  # Whether the chain is fully synced
  isSynced: Boolean!
}

# HealthStatus represents the health of a chain connection
type HealthStatus {
  # Whether the chain is healthy
  isHealthy: Boolean!

  # Last successful heartbeat timestamp
  lastHeartbeat: DateTime

  # Current latency to RPC endpoint in milliseconds
  latencyMs: BigInt

  # Number of consecutive failures
  consecutiveFailures: Int!

  # Last error message (if any)
  lastError: String

  # Connection uptime percentage
  uptimePercentage: Float!
}

# ========== Address Watchlist Types ==========

# WatchEventType represents the type of watch event
enum WatchEventType {
  TX_FROM
  TX_TO
  ERC20_TRANSFER
  ERC721_TRANSFER
  LOG
}

# WatchedAddress represents an address being monitored
type WatchedAddress {
  # Unique watchlist entry ID
  id: ID!

  # Monitored address
  address: Address!

  # Chain ID this address is monitored on
  chainId: String!

  # User-provided label
  label: String

  # Event filter configuration
  filter: WatchFilter!

  # Creation timestamp
  createdAt: DateTime!

  # Statistics about this watched address
  stats: WatchStats

  # Recent events for this address
  recentEvents(limit: Int): [WatchEvent!]!
}

# WatchFilter defines which events to monitor for an address
type WatchFilter {
  # Monitor transactions where address is sender
  txFrom: Boolean!

  # Monitor transactions where address is recipient
  txTo: Boolean!

  # Monitor ERC20 Transfer events
  erc20: Boolean!

  # Monitor ERC721 Transfer events
  erc721: Boolean!

  # Monitor all logs emitted by address
  logs: Boolean!

  # Minimum transaction value filter (in wei)
  minValue: BigInt
}

# WatchStats provides statistics about a watched address
type WatchStats {
  # Total number of events captured
  totalEvents: BigInt!

  # Number of events in last 24 hours
  eventsLast24h: BigInt!

  # Last event timestamp
  lastEventAt: DateTime
}

# WatchEvent represents an event captured for a watched address
type WatchEvent {
  # Unique event ID
  id: ID!

  # Watched address ID this event belongs to
  addressId: String!

  # Chain ID where event occurred
  chainId: String!

  # Type of event
  eventType: WatchEventType!

  # Block number
  blockNumber: BigInt!

  # Transaction hash
  txHash: Hash!

  # Log index (for log events)
  logIndex: Int

  # Event data (JSON encoded)
  data: JSON!

  # Event timestamp
  timestamp: DateTime!
}

# BlockWithChain represents a block with its chain context
type BlockWithChain {
  # Chain ID
  chainId: String!

  # Block data
  block: Block!
}

# Block represents an Ethereum block
type Block {
  # Block number (height)
  number: BigInt!

  # Block hash
  hash: Hash!

  # Parent block hash
  parentHash: Hash!

  # Timestamp of the block
  timestamp: BigInt!

  # Block nonce
  nonce: Bytes!

  # Miner address (coinbase)
  miner: Address!

  # Difficulty
  difficulty: BigInt!

  # Total difficulty
  totalDifficulty: BigInt

  # Gas limit
  gasLimit: BigInt!

  # Gas used
  gasUsed: BigInt!

  # Base fee per gas (EIP-1559, post-London)
  baseFeePerGas: BigInt

  # Withdrawals merkle root (post-Shanghai)
  withdrawalsRoot: Hash

  # Blob gas used (EIP-4844)
  blobGasUsed: BigInt

  # Excess blob gas (EIP-4844)
  excessBlobGas: BigInt

  # Extra data
  extraData: Bytes!

  # Size in bytes
  size: BigInt!

  # Transactions in this block
  transactions: [Transaction!]!

  # Transaction count
  transactionCount: Int!

  # Alias for transactionCount (frontend compatibility)
  txCount: Int!

  # Uncle blocks (ommers)
  uncles: [Hash!]!
}

# Transaction represents an Ethereum transaction
type Transaction {
  # Transaction hash
  hash: Hash!

  # Block number containing this transaction
  blockNumber: BigInt!

  # Block hash containing this transaction
  blockHash: Hash!

  # Transaction index in block
  transactionIndex: Int!

  # From address
  from: Address!

  # To address (null for contract creation)
  to: Address

  # Contract address created by this transaction (null if not a contract creation)
  contractAddress: Address

  # Value transferred
  value: BigInt!

  # Gas limit
  gas: BigInt!

  # Gas price
  gasPrice: BigInt

  # Max fee per gas (EIP-1559)
  maxFeePerGas: BigInt

  # Max priority fee per gas (EIP-1559)
  maxPriorityFeePerGas: BigInt

  # Transaction type (0x00=Legacy, 0x01=AccessList, 0x02=DynamicFee, 0x03=Blob, 0x04=SetCode, 0x16=FeeDelegation)
  type: Int!

  # Input data
  input: Bytes!

  # Nonce
  nonce: BigInt!

  # V signature value
  v: BigInt!

  # R signature value
  r: Bytes!

  # S signature value
  s: Bytes!

  # Chain ID
  chainId: BigInt

  # Access list (EIP-2930)
  accessList: [AccessListEntry!]

  # Transaction receipt
  receipt: Receipt

  # Fee payer address (Fee Delegation, type 0x16)
  feePayer: Address

  # Fee payer signatures (Fee Delegation, type 0x16)
  feePayerSignatures: [FeePayerSignature!]

  # Authorization list for SetCode transactions (EIP-7702, type 0x04)
  authorizationList: [SetCodeAuthorization!]
}

# FeePayerSignature represents a fee payer signature in Fee Delegation transactions
type FeePayerSignature {
  # V signature value
  v: BigInt!

  # R signature value
  r: Bytes!

  # S signature value
  s: Bytes!
}

# SetCodeAuthorization represents an EIP-7702 authorization for SetCode transactions (type 0x04)
type SetCodeAuthorization {
  # Chain ID for replay protection
  chainId: BigInt!

  # Address that will have code installed
  address: Address!

  # Nonce of the authorizer account
  nonce: BigInt!

  # Y parity of signature (0 or 1)
  yParity: Int!

  # R signature value
  r: Bytes!

  # S signature value
  s: Bytes!

  # Derived authority address (signer of this authorization)
  authority: Address
}

# SetCodeAuthorizationWithTx represents an EIP-7702 authorization with full transaction context
type SetCodeAuthorizationWithTx {
  # Transaction reference
  txHash: Hash!
  blockNumber: BigInt!
  blockHash: Hash!
  transactionIndex: Int!
  authorizationIndex: Int!

  # Authorization data
  chainId: BigInt!
  address: Address!
  nonce: BigInt!
  yParity: Int!
  r: Bytes!
  s: Bytes!
  authority: Address

  # Validation result
  applied: Boolean!
  error: String

  # Timestamp
  timestamp: BigInt!
}

# SetCodeAuthorizationConnection for pagination
type SetCodeAuthorizationConnection {
  nodes: [SetCodeAuthorizationWithTx!]!
  totalCount: Int!
  pageInfo: PageInfo!
}

# AddressSetCodeInfo provides SetCode-specific information for an address
type AddressSetCodeInfo {
  # Address being queried
  address: Address!

  # Delegation state
  hasDelegation: Boolean!
  delegationTarget: Address

  # Activity counts
  asTargetCount: Int!
  asAuthorityCount: Int!

  # Last activity
  lastActivityBlock: BigInt
  lastActivityTimestamp: BigInt
}

# AccessListEntry represents an access list entry
type AccessListEntry {
  address: Address!
  storageKeys: [Hash!]!
}

# Receipt represents a transaction receipt
type Receipt {
  # Transaction hash
  transactionHash: Hash!

  # Block number
  blockNumber: BigInt!

  # Block hash
  blockHash: Hash!

  # Transaction index
  transactionIndex: Int!

  # Contract address (for contract creation)
  contractAddress: Address

  # Gas used
  gasUsed: BigInt!

  # Cumulative gas used
  cumulativeGasUsed: BigInt!

  # Effective gas price
  effectiveGasPrice: BigInt!

  # Status (1 for success, 0 for failure)
  status: Int!

  # Logs
  logs: [Log!]!

  # Logs bloom filter
  logsBloom: Bytes!
}

# Log represents an event log
type Log {
  # Address that generated the log
  address: Address!

  # Topics
  topics: [Hash!]!

  # Data
  data: Bytes!

  # Block number
  blockNumber: BigInt!

  # Block hash
  blockHash: Hash!

  # Transaction hash
  transactionHash: Hash!

  # Transaction index
  transactionIndex: Int!

  # Log index
  logIndex: Int!

  # Removed (true if log was removed due to chain reorg)
  removed: Boolean!
}

# BalanceSnapshot represents an address balance at a specific block
type BalanceSnapshot {
  # Block number
  blockNumber: BigInt!

  # Account balance at this block
  balance: BigInt!

  # Change in balance (positive or negative)
  delta: BigInt!

  # Transaction that caused the balance change (may be null)
  transactionHash: Hash
}

# ========== Multi-Chain Input Types ==========

# Input for registering a new chain
input RegisterChainInput {
  # Human-readable chain name
  name: String!

  # RPC endpoint URL
  rpcEndpoint: String!

  # WebSocket endpoint URL (optional)
  wsEndpoint: String

  # Chain ID (EVM chain ID)
  chainId: BigInt!

  # Adapter type (auto, evm, stableone, anvil)
  adapterType: String

  # Start block height for indexing
  startHeight: BigInt
}

# ========== Watchlist Input Types ==========

# Input for watching an address
input WatchAddressInput {
  # Address to monitor
  address: Address!

  # Chain ID to monitor on
  chainId: String!

  # User-provided label
  label: String

  # Event filter configuration
  filter: WatchFilterInput!
}

# Input for watch filter configuration
input WatchFilterInput {
  # Monitor transactions where address is sender
  txFrom: Boolean!

  # Monitor transactions where address is recipient
  txTo: Boolean!

  # Monitor ERC20 Transfer events
  erc20: Boolean!

  # Monitor ERC721 Transfer events
  erc721: Boolean!

  # Monitor all logs emitted by address
  logs: Boolean!

  # Minimum transaction value filter (in wei)
  minValue: BigInt
}

# Filter input for querying blocks
input BlockFilter {
  # Filter by number range
  numberFrom: BigInt
  numberTo: BigInt

  # Filter by timestamp range
  timestampFrom: BigInt
  timestampTo: BigInt

  # Filter by miner address
  miner: Address
}

# Filter input for querying transactions
input TransactionFilter {
  # Filter by block number range
  blockNumberFrom: BigInt
  blockNumberTo: BigInt

  # Filter by from address
  from: Address

  # Filter by to address
  to: Address

  # Filter by transaction type
  type: Int
}

# Filter input for querying logs
input LogFilter {
  # Filter by address
  address: Address

  # Filter by topics
  topics: [Hash!]

  # Filter by block number range
  blockNumberFrom: BigInt
  blockNumberTo: BigInt
}

# Transaction direction filter
enum TransactionDirection {
  SENT
  RECEIVED
  ALL
}

# Filter input for historical transaction queries
input HistoricalTransactionFilter {
  # Filter by block number range
  fromBlock: BigInt!
  toBlock: BigInt!

  # Filter by minimum value
  minValue: BigInt

  # Filter by maximum value
  maxValue: BigInt

  # Filter by transaction type (0=all, 1=sent, 2=received)
  txType: Int

  # Filter by success status only
  successOnly: Boolean

  # Filter by fee delegation status (true=fee delegated only, false=non-fee delegated only)
  isFeeDelegated: Boolean

  # Filter by function selector (first 4 bytes of input data, e.g., "0xa9059cbb")
  methodId: String

  # Filter by minimum gas used
  minGasUsed: BigInt

  # Filter by maximum gas used
  maxGasUsed: BigInt

  # Filter by transaction direction (overrides txType if both specified)
  direction: TransactionDirection

  # Start time filter (Unix timestamp, overrides fromBlock)
  fromTime: BigInt

  # End time filter (Unix timestamp, overrides toBlock)
  toTime: BigInt
}

# Pagination input
input PaginationInput {
  # Number of items to return (default: 10, max: 100)
  limit: Int

  # Offset for pagination
  offset: Int
}

# Subscription root type for real-time updates
# All subscriptions support optional replayLast parameter to receive recent historical events
type Subscription {
  # ========== Multi-Chain Subscriptions ==========

  # Subscribe to chain status updates
  chainStatus(chainId: ID!): Chain!

  # Subscribe to new blocks from multiple chains
  # chainIds: Filter by specific chain IDs (receives all if not specified)
  newBlockMultiChain(chainIds: [String!]): BlockWithChain!

  # ========== Watchlist Subscriptions ==========

  # Subscribe to events for a specific watched address
  watchedAddressEvents(addressId: ID!): WatchEvent!

  # Subscribe to all watch events for a chain
  watchedAddressEventsByChain(chainId: String!): WatchEvent!

  # ========== Existing Subscriptions ==========

  # Subscribe to new blocks as they are indexed
  # replayLast: Number of recent blocks to replay immediately upon subscription (max 100)
  newBlock(replayLast: Int): Block!

  # Subscribe to new transactions as they are indexed
  # replayLast: Number of recent transactions to replay immediately upon subscription (max 100)
  newTransaction(replayLast: Int): Transaction!

  # Subscribe to new pending transactions (if available)
  newPendingTransactions(limit: Int): Transaction!

  # Subscribe to new logs matching a filter
  # replayLast: Number of recent logs to replay immediately upon subscription (max 100)
  logs(filter: LogFilter!, replayLast: Int): Log!

  # Subscribe to system contract events
  # Filter by contract address to receive events only from specific contracts
  # replayLast: Number of recent events to replay immediately upon subscription (max 100)
  systemContractEvents(filter: SystemContractSubscriptionFilter, replayLast: Int): SystemContractEventMessage!

  # Subscribe to events from dynamically registered contracts
  # replayLast: Number of recent events to replay immediately upon subscription (max 100)
  dynamicContractEvents(filter: DynamicContractSubscriptionFilter, replayLast: Int): DynamicContractEvent!

  # Subscribe to new consensus block events with validator participation data
  # replayLast: Number of recent consensus blocks to replay immediately upon subscription (max 100)
  consensusBlock(replayLast: Int): ConsensusBlockSub!

  # Subscribe to chain fork detection events
  # replayLast: Number of recent fork events to replay immediately upon subscription (max 100)
  consensusFork(replayLast: Int): ConsensusForkSub!

  # Subscribe to validator set change events at epoch boundaries
  # replayLast: Number of recent validator changes to replay immediately upon subscription (max 100)
  consensusValidatorChange(replayLast: Int): ConsensusValidatorChangeSub!

  # Subscribe to consensus errors and anomalies (round changes, low participation)
  # replayLast: Number of recent errors to replay immediately upon subscription (max 100)
  consensusError(replayLast: Int): ConsensusErrorSub!
}

# Real-time consensus block data from subscription
type ConsensusBlockSub {
  # Block number
  blockNumber: BigInt!
  # Block hash
  blockHash: Hash!
  # Block timestamp
  timestamp: BigInt!
  # Consensus round number
  round: Int!
  # Previous round number
  prevRound: Int!
  # Whether round changed from 0
  roundChanged: Boolean!
  # Block proposer address
  proposer: Address!
  # Total number of validators
  validatorCount: Int!
  # Number of prepare signatures
  prepareCount: Int!
  # Number of commit signatures
  commitCount: Int!
  # Validator participation rate (0-100)
  participationRate: Float!
  # Rate of validators who missed commit (0-100)
  missedValidatorRate: Float!
  # Whether this block is at epoch boundary
  isEpochBoundary: Boolean!
  # Epoch number (only at epoch boundaries)
  epochNumber: BigInt
  # Validator addresses for the epoch (only at epoch boundaries)
  epochValidators: [Address!]
}

# Chain fork detection event from subscription
type ConsensusForkSub {
  # Block number where fork occurred
  forkBlockNumber: BigInt!
  # Hash of the fork block
  forkBlockHash: Hash!
  # Hash of chain 1 tip
  chain1Hash: Hash!
  # Height of chain 1
  chain1Height: BigInt!
  # Total weight/difficulty of chain 1
  chain1Weight: String!
  # Hash of chain 2 tip
  chain2Hash: Hash!
  # Height of chain 2
  chain2Height: BigInt!
  # Total weight/difficulty of chain 2
  chain2Weight: String!
  # Whether the fork has been resolved
  resolved: Boolean!
  # Winning chain (1 or 2, 0 if unresolved)
  winningChain: Int!
  # Unix timestamp when fork was detected
  detectedAt: BigInt!
  # Blocks between fork and detection
  detectionLag: BigInt!
}

# Validator set change event from subscription
type ConsensusValidatorChangeSub {
  # Block number where change occurred
  blockNumber: BigInt!
  # Block hash
  blockHash: Hash!
  # Block timestamp
  timestamp: BigInt!
  # Epoch number
  epochNumber: BigInt!
  # Whether this is an epoch boundary
  isEpochBoundary: Boolean!
  # Type of change: added, removed, replaced, reordered
  changeType: String!
  # Previous validator count
  previousValidatorCount: Int!
  # New validator count
  newValidatorCount: Int!
  # Addresses of added validators
  addedValidators: [Address!]
  # Addresses of removed validators
  removedValidators: [Address!]
  # Current validator set after change
  validatorSet: [Address!]
  # Additional information (JSON encoded)
  additionalInfo: String
}

# Consensus error or anomaly event from subscription
type ConsensusErrorSub {
  # Block number where error occurred
  blockNumber: BigInt!
  # Block hash
  blockHash: Hash!
  # Block timestamp
  timestamp: BigInt!
  # Error type: round_change, missed_validators, low_participation, etc.
  errorType: String!
  # Severity level: critical, high, medium, low
  severity: String!
  # Human-readable error message
  errorMessage: String!
  # Consensus round number
  round: Int!
  # Expected number of validators
  expectedValidators: Int!
  # Actual number of signers
  actualSigners: Int!
  # Current participation rate (0-100)
  participationRate: Float!
  # Whether consensus was impacted
  consensusImpacted: Boolean!
  # Blocks until recovery (0 if not applicable)
  recoveryTime: BigInt!
  # Addresses of validators who missed
  missedValidators: [Address!]
  # Additional error details (JSON encoded)
  errorDetails: String
}

# Filter for dynamic contract event subscription
input DynamicContractSubscriptionFilter {
  # Filter by contract address
  contract: Address

  # Filter by event names
  eventNames: [String!]
}

# Filter for system contract event subscription
input SystemContractSubscriptionFilter {
  # Filter by contract address (optional, receives all if not specified)
  contract: Address

  # Filter by specific event types (optional, receives all if not specified)
  eventTypes: [String!]
}

# Real-time system contract event message
type SystemContractEventMessage {
  # Contract address that emitted the event
  contract: Address!

  # Event name (e.g., "Mint", "Burn", "ProposalCreated")
  eventName: String!

  # Block number
  blockNumber: BigInt!

  # Transaction hash
  transactionHash: Hash!

  # Log index in the transaction
  logIndex: Int!

  # Event-specific data as JSON string
  data: String!

  # Timestamp when the event was detected
  timestamp: BigInt!
}

# Query root type
type Query {
  # ========== Multi-Chain Queries ==========

  # Get all registered chains
  chains: [Chain!]!

  # Get a chain by ID
  chain(id: ID!): Chain

  # Get chain health status
  chainHealth(id: ID!): HealthStatus

  # ========== Watchlist Queries ==========

  # Get all watched addresses with optional filtering
  watchedAddresses(chainId: String, limit: Int, offset: Int): [WatchedAddress!]!

  # Get a watched address by ID
  watchedAddress(id: ID!): WatchedAddress

  # Get recent watch events with optional filtering
  watchEvents(
    addressId: ID
    chainId: String
    eventType: WatchEventType
    limit: Int
    offset: Int
  ): [WatchEvent!]!

  # ========== Existing Queries ==========

  # Get the latest indexed block height
  latestHeight: BigInt!

  # Get a block by number
  block(number: BigInt!): Block

  # Get a block by hash
  blockByHash(hash: Hash!): Block

  # Get blocks with optional filtering and pagination
  blocks(filter: BlockFilter, pagination: PaginationInput): BlockConnection!

  # Get blocks in a specific range (optimized for frontend catch-up)
  # Returns blocks from startNumber to endNumber (inclusive)
  # Maximum range is 100 blocks per request
  blocksRange(
    startNumber: BigInt!
    endNumber: BigInt!
    includeTransactions: Boolean
    includeReceipts: Boolean
  ): BlockRangeResult!

  # Get a transaction by hash
  transaction(hash: Hash!): Transaction

  # Get transactions with optional filtering and pagination
  transactions(filter: TransactionFilter, pagination: PaginationInput): TransactionConnection!

  # Get transactions by address (sent from or received by)
  transactionsByAddress(address: Address!, pagination: PaginationInput): TransactionConnection!

  # Get a receipt by transaction hash
  receipt(transactionHash: Hash!): Receipt

  # Get receipts for a block
  receiptsByBlock(blockNumber: BigInt!): [Receipt!]!

  # Get logs with filtering
  logs(filter: LogFilter!, pagination: PaginationInput): LogConnection!

  # ========== Historical Data Queries ==========

  # Get blocks within a time range
  blocksByTimeRange(
    fromTime: BigInt!
    toTime: BigInt!
    pagination: PaginationInput
  ): BlockConnection!

  # Get the block closest to a specific timestamp
  blockByTimestamp(timestamp: BigInt!): Block

  # Get filtered transactions for an address with advanced filtering
  transactionsByAddressFiltered(
    address: Address!
    filter: HistoricalTransactionFilter!
    pagination: PaginationInput
  ): TransactionConnection!

  # Get address balance at a specific block (0 for latest)
  addressBalance(
    address: Address!
    blockNumber: BigInt
  ): BigInt!

  # Get balance history for an address
  balanceHistory(
    address: Address!
    fromBlock: BigInt!
    toBlock: BigInt!
    pagination: PaginationInput
  ): BalanceHistoryConnection!

  # Get total number of indexed blocks
  blockCount: BigInt!

  # Get total number of indexed transactions
  transactionCount: BigInt!

  # ========== Analytics Queries ==========

  # Get top miners by block count
  topMiners(
    limit: Int
    fromBlock: BigInt
    toBlock: BigInt
  ): [MinerStats!]!

  # Get token balances for an address (ERC-20/721/1155)
  tokenBalances(
    address: Address!
    tokenType: String
  ): [TokenBalance!]!

  # ========== System Contract Queries ==========

  # Get current total supply of native coin
  totalSupply: BigInt!

  # Get mint events
  mintEvents(
    filter: SystemContractEventFilter!
    pagination: PaginationInput
  ): MintEventConnection!

  # Get burn events
  burnEvents(
    filter: SystemContractEventFilter!
    pagination: PaginationInput
  ): BurnEventConnection!

  # Get list of active minters
  activeMinters: [MinterInfo!]!

  # Get minter allowance for a specific minter
  minterAllowance(minter: Address!): BigInt!

  # Get minter configuration history
  minterHistory(minter: Address!): [MinterConfigEvent!]!

  # Get minter configuration change history across all minters in a block range
  minterConfigHistory(filter: SystemContractEventFilter!): [MinterConfigEvent!]!

  # Get token burn history (alias for burnEvents)
  burnHistory(
    filter: SystemContractEventFilter!
    pagination: PaginationInput
  ): BurnEventConnection!

  # Get list of authorized accounts from GovCouncil contract
  authorizedAccounts: [Address!]!

  # Get list of active validators
  activeValidators: [ValidatorInfo!]!

  # Get validator change history
  validatorHistory(
    validator: Address!
  ): [ValidatorChangeEvent!]!

  # Get gas tip update history
  gasTipHistory(
    filter: SystemContractEventFilter!
  ): [GasTipUpdateEvent!]!

  # Get list of blacklisted addresses
  blacklistedAddresses: [Address!]!

  # Get blacklist event history for an address
  blacklistHistory(
    address: Address!
  ): [BlacklistEvent!]!

  # Get governance proposals
  proposals(
    filter: ProposalFilter
    pagination: PaginationInput
  ): ProposalConnection!

  # Get a specific proposal by ID
  proposal(
    contract: Address!
    proposalId: BigInt!
  ): Proposal

  # Get votes for a specific proposal
  proposalVotes(
    contract: Address!
    proposalId: BigInt!
  ): [ProposalVote!]!

  # Get member change history for a contract
  memberHistory(
    contract: Address!
  ): [MemberChangeEvent!]!

  # Get emergency pause event history for a contract
  emergencyPauseHistory(
    contract: Address!
  ): [EmergencyPauseEvent!]!

  # Get deposit mint proposals
  depositMintProposals(
    filter: SystemContractEventFilter!
    status: ProposalStatus
  ): [DepositMintProposal!]!

  # Get max proposals per member update history
  maxProposalsUpdateHistory(
    contract: Address!
  ): [MaxProposalsUpdateEvent!]!

  # Get proposal execution skipped events
  proposalExecutionSkippedEvents(
    contract: Address!
    proposalId: BigInt
  ): [ProposalExecutionSkippedEvent!]!

  # ========== WBFT Consensus Queries ==========

  # Get WBFT consensus metadata for a block by number
  wbftBlockExtra(blockNumber: BigInt!): WBFTBlockExtra

  # Get WBFT consensus metadata for a block by hash
  wbftBlockExtraByHash(blockHash: Hash!): WBFTBlockExtra

  # Get epoch information for a specific epoch
  epochInfo(epochNumber: BigInt!): EpochInfo

  # Get the most recent epoch information
  latestEpochInfo: EpochInfo

  # Get paginated list of epochs (latest first)
  epochs(pagination: PaginationInput): EpochSummaryConnection!

  # Get signing statistics for a specific validator
  validatorSigningStats(
    validatorAddress: Address!
    fromBlock: BigInt!
    toBlock: BigInt!
  ): ValidatorSigningStats

  # Get signing statistics for all validators in a block range
  allValidatorsSigningStats(
    fromBlock: BigInt!
    toBlock: BigInt!
    pagination: PaginationInput
  ): ValidatorSigningStatsConnection!

  # Get detailed signing activity for a specific validator
  validatorSigningActivity(
    validatorAddress: Address!
    fromBlock: BigInt!
    toBlock: BigInt!
    pagination: PaginationInput
  ): ValidatorSigningActivityConnection!

  # Get list of validators who signed a specific block
  blockSigners(blockNumber: BigInt!): BlockSigners

  # ========== Enhanced Consensus Queries ==========

  # Get complete consensus information for a specific block
  consensusData(blockNumber: BigInt!): ConsensusData

  # Get enhanced validator statistics over a block range
  validatorStats(address: Address!, fromBlock: BigInt!, toBlock: BigInt!): ValidatorStats

  # Get detailed validator participation over a block range
  validatorParticipation(
    address: Address!
    fromBlock: BigInt!
    toBlock: BigInt!
    pagination: PaginationInput
  ): ValidatorParticipation

  # Get enhanced statistics for all validators in a block range
  allValidatorStats(
    fromBlock: BigInt!
    toBlock: BigInt!
    pagination: PaginationInput
  ): [ValidatorStats!]!

  # Get enhanced epoch data by epoch number
  epochData(epochNumber: BigInt!): EpochData

  # Get the latest enhanced epoch data
  latestEpochData: EpochData

  # ========== Address Indexing Queries ==========

  # Get comprehensive overview of an address (balance, tx counts, contract info, etc.)
  addressOverview(address: Address!): AddressOverview!

  # Get contract creation information by contract address
  contractCreation(address: Address!): ContractCreation

  # Get contract verification information by contract address
  contractVerification(address: Address!): ContractVerification

  # Get all deployed contracts with pagination (newest first)
  contracts(pagination: PaginationInput): ContractCreationConnection!

  # Get contracts created by a specific address
  contractsByCreator(
    creator: Address!
    pagination: PaginationInput
  ): ContractCreationConnection!

  # Get internal transactions for a transaction hash
  internalTransactions(txHash: Hash!): [InternalTransaction!]!

  # Get internal transactions involving a specific address
  internalTransactionsByAddress(
    address: Address!
    isFrom: Boolean!
    pagination: PaginationInput
  ): InternalTransactionConnection!

  # Get ERC20 transfer by transaction hash and log index
  erc20Transfer(txHash: Hash!, logIndex: Int!): ERC20Transfer

  # Get ERC20 transfers for a specific token contract
  erc20TransfersByToken(
    token: Address!
    pagination: PaginationInput
  ): ERC20TransferConnection!

  # Get ERC20 transfers involving a specific address
  erc20TransfersByAddress(
    address: Address!
    isFrom: Boolean!
    pagination: PaginationInput
  ): ERC20TransferConnection!

  # Get ERC721 transfer by transaction hash and log index
  erc721Transfer(txHash: Hash!, logIndex: Int!): ERC721Transfer

  # Get ERC721 transfers for a specific NFT contract
  erc721TransfersByToken(
    token: Address!
    pagination: PaginationInput
  ): ERC721TransferConnection!

  # Get ERC721 transfers involving a specific address
  erc721TransfersByAddress(
    address: Address!
    isFrom: Boolean!
    pagination: PaginationInput
  ): ERC721TransferConnection!

  # Get current owner of an NFT token
  erc721Owner(token: Address!, tokenId: BigInt!): Address

  # Get all NFTs owned by a specific address
  nftsByOwner(
    owner: Address!
    pagination: PaginationInput
  ): NFTOwnershipConnection!

  # ========== Dynamic Contract Queries ==========

  # Get a registered contract by address
  registeredContract(address: Address!): RegisteredContract

  # Get all registered contracts
  registeredContracts: [RegisteredContract!]!

  # Get events from a registered contract
  dynamicContractEvents(
    filter: DynamicContractEventFilter!
    pagination: PaginationInput
  ): [DynamicContractEvent!]!

  # ========== RPC Proxy Queries (Real-time Chain Data) ==========

  # Get live balance directly from chain RPC (real-time, not from indexed storage)
  liveBalance(
    address: Address!
    blockNumber: BigInt
  ): LiveBalanceResult!

  # Execute a read-only contract call via RPC proxy
  contractCall(
    address: Address!
    method: String!
    params: String
    abi: String
  ): ContractCallResult!

  # Get real-time transaction status from chain
  transactionStatus(txHash: Hash!): TransactionStatusResult!

  # Get internal transactions using debug_traceTransaction RPC
  internalTransactionsRPC(txHash: Hash!): InternalTransactionsRPCResult!

  # Get RPC proxy service metrics
  rpcProxyMetrics: RPCProxyMetrics!

  # ========== Fee Delegation Queries ==========

  # Get overall fee delegation statistics
  feeDelegationStats(
    fromBlock: BigInt
    toBlock: BigInt
    fromTime: BigInt
    toTime: BigInt
  ): FeeDelegationStats!

  # Get top fee payers by transaction count
  topFeePayers(
    limit: Int
    fromBlock: BigInt
    toBlock: BigInt
    fromTime: BigInt
    toTime: BigInt
  ): TopFeePayersResult!

  # Get statistics for a specific fee payer
  feePayerStats(
    address: Address!
    fromBlock: BigInt
    toBlock: BigInt
    fromTime: BigInt
    toTime: BigInt
  ): FeePayerStats!

  # Get aggregated statistics for an address
  addressStats(address: Address!): AddressStats!

  # ========== Token Metadata Queries ==========

  # Get token metadata by contract address
  tokenMetadata(address: Address!): TokenMetadata

  # List tokens with optional standard filter and pagination
  tokens(
    standard: TokenStandard
    pagination: PaginationInput
  ): TokenMetadataConnection!

  # Search tokens by name or symbol
  searchTokens(
    query: String!
    limit: Int
  ): [TokenMetadata!]!

  # Get token count by standard
  tokenCount(standard: TokenStandard): Int!

  # ========== EIP-7702 SetCode Queries ==========

  # Get a specific SetCode authorization by transaction hash and index
  setCodeAuthorization(
    txHash: Hash!
    authIndex: Int!
  ): SetCodeAuthorizationWithTx

  # Get all SetCode authorizations in a transaction
  setCodeAuthorizationsByTx(
    txHash: Hash!
  ): [SetCodeAuthorizationWithTx!]!

  # Get SetCode authorizations where address is the target (received delegations)
  setCodeAuthorizationsByTarget(
    target: Address!
    pagination: PaginationInput
  ): SetCodeAuthorizationConnection!

  # Get SetCode authorizations where address is the authority (signed delegations)
  setCodeAuthorizationsByAuthority(
    authority: Address!
    pagination: PaginationInput
  ): SetCodeAuthorizationConnection!

  # Get SetCode information for an address
  addressSetCodeInfo(
    address: Address!
  ): AddressSetCodeInfo!

  # Get SetCode transactions in a block
  setCodeTransactionsInBlock(
    blockNumber: BigInt!
  ): [Transaction!]!

  # Get recent SetCode transactions (global)
  recentSetCodeTransactions(
    limit: Int
  ): [Transaction!]!

  # Get total SetCode transaction count
  setCodeTransactionCount: Int!
}

# Block connection for pagination
type BlockConnection {
  # List of blocks
  nodes: [Block!]!

  # Total count
  totalCount: Int!

  # Page info
  pageInfo: PageInfo!
}

# Block range result for efficient bulk data transfer
# Used for frontend catch-up scenarios
type BlockRangeResult {
  # List of blocks in the range
  blocks: [Block!]!

  # Start block number in the result
  startNumber: BigInt!

  # End block number in the result
  endNumber: BigInt!

  # Number of blocks returned
  count: Int!

  # Whether there are more blocks after endNumber
  hasMore: Boolean!

  # Latest known block height (for sync status)
  latestHeight: BigInt!
}

# Transaction connection for pagination
type TransactionConnection {
  # List of transactions
  nodes: [Transaction!]!

  # Total count
  totalCount: Int!

  # Page info
  pageInfo: PageInfo!
}

# Log connection for pagination
type LogConnection {
  # List of logs
  nodes: [Log!]!

  # Total count
  totalCount: Int!

  # Page info
  pageInfo: PageInfo!
}

# Page info for pagination
type PageInfo {
  # Has next page
  hasNextPage: Boolean!

  # Has previous page
  hasPreviousPage: Boolean!

  # Start cursor
  startCursor: String

  # End cursor
  endCursor: String
}

# Balance history connection for pagination
type BalanceHistoryConnection {
  # List of balance snapshots
  nodes: [BalanceSnapshot!]!

  # Total count
  totalCount: Int!

  # Page info
  pageInfo: PageInfo!
}

# ========== Multi-Chain Connection Types ==========

# Chain connection for pagination
type ChainConnection {
  # List of chains
  nodes: [Chain!]!

  # Total count
  totalCount: Int!

  # Page info
  pageInfo: PageInfo!
}

# ========== Watchlist Connection Types ==========

# Watched address connection for pagination
type WatchedAddressConnection {
  # List of watched addresses
  nodes: [WatchedAddress!]!

  # Total count
  totalCount: Int!

  # Page info
  pageInfo: PageInfo!
}

# Watch event connection for pagination
type WatchEventConnection {
  # List of watch events
  nodes: [WatchEvent!]!

  # Total count
  totalCount: Int!

  # Page info
  pageInfo: PageInfo!
}

# MinerStats represents mining statistics for a miner address
type MinerStats {
  # Miner address
  address: Address!

  # Number of blocks mined
  blockCount: BigInt!

  # Most recent block mined
  lastBlockNumber: BigInt!

  # Timestamp of last block mined
  lastBlockTime: BigInt!

  # Percentage of total blocks mined
  percentage: Float!

  # Total rewards earned (in Wei)
  totalRewards: BigInt!
}

# TokenBalance represents a token balance for an address
type TokenBalance {
  # Token contract address
  address: Address!

  # Token standard (ERC20, ERC721, ERC1155)
  tokenType: String!

  # Token balance
  balance: BigInt!

  # Token ID (for ERC721/ERC1155, null for ERC20)
  tokenId: BigInt

  # Token name
  name: String

  # Token symbol
  symbol: String

  # Token decimals (ERC20 only)
  decimals: Int

  # Token metadata (JSON string, for NFTs)
  metadata: String
}

# AddressOverview provides a comprehensive summary of an address
type AddressOverview {
  # The address being queried
  address: Address!

  # Whether this address is a contract
  isContract: Boolean!

  # Native coin balance (in Wei)
  balance: BigInt!

  # Total transaction count (sent + received)
  transactionCount: Int!

  # Sent transaction count
  sentCount: Int!

  # Received transaction count
  receivedCount: Int!

  # Internal transaction count
  internalTxCount: Int!

  # ERC20 token balance count (number of different tokens held)
  erc20TokenCount: Int!

  # ERC721 NFT count (number of NFTs owned)
  erc721TokenCount: Int!

  # Contract creation info (if this is a contract)
  contractInfo: ContractCreation

  # Contract verification status (if this is a contract)
  verificationInfo: ContractVerification

  # First seen timestamp (first transaction involving this address)
  firstSeen: BigInt

  # Last seen timestamp (last transaction involving this address)
  lastSeen: BigInt
}

# ========== System Contract Types ==========

# ProposalStatus enum
enum ProposalStatus {
  NONE
  VOTING
  APPROVED
  EXECUTED
  CANCELLED
  EXPIRED
  FAILED
  REJECTED
}

# MintEvent represents a mint event from NativeCoinAdapter
type MintEvent {
  # Block number
  blockNumber: BigInt!

  # Transaction hash
  transactionHash: Hash!

  # Alias for transactionHash (frontend compatibility)
  txHash: Hash!

  # Minter address
  minter: Address!

  # Recipient address
  to: Address!

  # Mint amount
  amount: BigInt!

  # Timestamp
  timestamp: BigInt!
}

# BurnEvent represents a burn event
type BurnEvent {
  # Block number
  blockNumber: BigInt!

  # Transaction hash
  transactionHash: Hash!

  # Alias for transactionHash (frontend compatibility)
  txHash: Hash!

  # Burner address
  burner: Address!

  # Burn amount
  amount: BigInt!

  # Timestamp
  timestamp: BigInt!

  # Withdrawal ID (for GovMinter)
  withdrawalId: String

  # Alias for withdrawalId (frontend compatibility)
  burnTxId: String
}

# MinterConfigEvent represents minter configuration changes
type MinterConfigEvent {
  # Block number
  blockNumber: BigInt!

  # Transaction hash
  transactionHash: Hash!

  # Minter address
  minter: Address!

  # Minter allowance
  allowance: BigInt!

  # Alias for transactionHash (frontend compatibility)
  txHash: Hash!

  # Action (configured or removed)
  action: String!

  # Whether the minter is active (derived from action)
  isActive: Boolean!

  # Timestamp
  timestamp: BigInt!
}

# Proposal represents a governance proposal
type Proposal {
  # Contract address
  contract: Address!

  # Proposal ID
  proposalId: BigInt!

  # Proposer address
  proposer: Address!

  # Action type
  actionType: Bytes!

  # Call data
  callData: Bytes!

  # Member version
  memberVersion: BigInt!

  # Required approvals
  requiredApprovals: Int!

  # Approved count
  approved: Int!

  # Rejected count
  rejected: Int!

  # Proposal status
  status: ProposalStatus!

  # Created timestamp
  createdAt: BigInt!

  # Executed timestamp (null if not executed)
  executedAt: BigInt

  # Block number
  blockNumber: BigInt!

  # Transaction hash
  transactionHash: Hash!
}

# ProposalVote represents a vote on a proposal
type ProposalVote {
  # Contract address
  contract: Address!

  # Proposal ID
  proposalId: BigInt!

  # Voter address
  voter: Address!

  # Approval (true for approve, false for reject)
  approval: Boolean!

  # Block number
  blockNumber: BigInt!

  # Transaction hash
  transactionHash: Hash!

  # Timestamp
  timestamp: BigInt!
}

# GasTipUpdateEvent represents a gas tip update
type GasTipUpdateEvent {
  # Block number
  blockNumber: BigInt!

  # Transaction hash
  transactionHash: Hash!

  # Old tip value
  oldTip: BigInt!

  # New tip value
  newTip: BigInt!

  # Updater address
  updater: Address!

  # Timestamp
  timestamp: BigInt!
}

# BlacklistEvent represents blacklist changes
type BlacklistEvent {
  # Block number
  blockNumber: BigInt!

  # Transaction hash
  transactionHash: Hash!

  # Account address
  account: Address!

  # Action (blacklisted or unblacklisted)
  action: String!

  # Proposal ID
  proposalId: BigInt

  # Timestamp
  timestamp: BigInt!
}

# ValidatorChangeEvent represents validator changes
type ValidatorChangeEvent {
  # Block number
  blockNumber: BigInt!

  # Transaction hash
  transactionHash: Hash!

  # Validator address
  validator: Address!

  # Action (added, removed, changed)
  action: String!

  # Old validator address (for changed action)
  oldValidator: Address

  # Timestamp
  timestamp: BigInt!
}

# MemberChangeEvent represents member changes in Gov contracts
type MemberChangeEvent {
  # Contract address
  contract: Address!

  # Block number
  blockNumber: BigInt!

  # Transaction hash
  transactionHash: Hash!

  # Member address
  member: Address!

  # Action (added, removed, changed)
  action: String!

  # Old member address (for changed action)
  oldMember: Address

  # Total members count
  totalMembers: BigInt!

  # New quorum value
  newQuorum: Int!

  # Timestamp
  timestamp: BigInt!
}

# EmergencyPauseEvent represents emergency pause/unpause events
type EmergencyPauseEvent {
  # Contract address
  contract: Address!

  # Block number
  blockNumber: BigInt!

  # Transaction hash
  transactionHash: Hash!

  # Proposal ID
  proposalId: BigInt

  # Action (paused or unpaused)
  action: String!

  # Timestamp
  timestamp: BigInt!
}

# MaxProposalsUpdateEvent represents max proposals per member update from GovBase
type MaxProposalsUpdateEvent {
  # Contract address
  contract: Address!

  # Block number
  blockNumber: BigInt!

  # Transaction hash
  transactionHash: Hash!

  # Old maximum proposals per member
  oldMax: BigInt!

  # New maximum proposals per member
  newMax: BigInt!

  # Timestamp
  timestamp: BigInt!
}

# ProposalExecutionSkippedEvent represents skipped proposal execution from GovCouncil
type ProposalExecutionSkippedEvent {
  # Contract address
  contract: Address!

  # Block number
  blockNumber: BigInt!

  # Transaction hash
  transactionHash: Hash!

  # Account address related to the skipped execution
  account: Address!

  # Proposal ID
  proposalId: BigInt!

  # Reason for skipping (e.g., ALREADY_BLACKLISTED, NOT_IN_BLACKLIST)
  reason: String!

  # Timestamp
  timestamp: BigInt!
}

# DepositMintProposal represents a deposit mint proposal from GovMinter
type DepositMintProposal {
  # Proposal ID
  proposalId: BigInt!

  # Requester address (member who proposed the mint)
  requester: Address!

  # Beneficiary address (recipient of minted tokens)
  beneficiary: Address!

  # Mint amount
  amount: BigInt!

  # Deposit ID (may be empty as indexed string is hashed)
  depositId: String!

  # Bank reference number
  bankReference: String!

  # Proposal status
  status: ProposalStatus!

  # Block number
  blockNumber: BigInt!

  # Transaction hash
  transactionHash: Hash!

  # Timestamp
  timestamp: BigInt!
}

# MinterInfo represents information about a minter
type MinterInfo {
  # Minter address
  address: Address!

  # Current allowance
  allowance: BigInt!

  # Is currently active
  isActive: Boolean!
}

# ValidatorInfo represents information about a validator
type ValidatorInfo {
  # Validator address
  address: Address!

  # Is currently active
  isActive: Boolean!
}

# Connections for pagination
type MintEventConnection {
  nodes: [MintEvent!]!
  totalCount: Int!
  pageInfo: PageInfo!
}

type BurnEventConnection {
  nodes: [BurnEvent!]!
  totalCount: Int!
  pageInfo: PageInfo!
}

type ProposalConnection {
  nodes: [Proposal!]!
  totalCount: Int!
  pageInfo: PageInfo!
}

type ProposalVoteConnection {
  nodes: [ProposalVote!]!
  totalCount: Int!
  pageInfo: PageInfo!
}

# Filter inputs for system contracts
input SystemContractEventFilter {
  # Filter by block number range
  fromBlock: BigInt!
  toBlock: BigInt!

  # Filter by specific address (minter, burner, validator, etc.)
  address: Address
}

input ProposalFilter {
  # Filter by contract address
  contract: Address!

  # Filter by status
  status: ProposalStatus

  # Filter by proposer
  proposer: Address
}

# ========== WBFT Consensus Types ==========

# WBFTAggregatedSeal represents an aggregated BLS signature from validators
type WBFTAggregatedSeal {
  # Bitmap of validators who signed
  sealers: Bytes!

  # Aggregated BLS signature (96 bytes)
  signature: Bytes!
}

# Candidate represents a validator candidate
type Candidate {
  # Validator address
  address: Address!

  # Diligence score (unit: 10^-6)
  diligence: BigInt!
}

# EpochInfo represents validator set information for an epoch
type EpochInfo {
  # Epoch number
  epochNumber: BigInt!

  # Block number where epoch info is stored
  blockNumber: BigInt!

  # Candidate list for next epoch
  candidates: [Candidate!]!

  # Validator indices for next epoch
  validators: [Int!]!

  # BLS public keys for next epoch
  blsPublicKeys: [Bytes!]!

  # Number of validators in this epoch
  validatorCount: Int!

  # Number of candidates in this epoch
  candidateCount: Int!

  # Validator count from previous epoch (null for epoch 0)
  previousEpochValidatorCount: Int

  # Timestamp of the epoch boundary block
  timestamp: BigInt
}

# WBFTBlockExtra represents WBFT consensus metadata for a block
type WBFTBlockExtra {
  # Block number
  blockNumber: BigInt!

  # Block hash
  blockHash: Hash!

  # BLS signature of block number
  randaoReveal: Bytes!

  # Previous block's round number
  prevRound: Int!

  # Previous block's prepare seal
  prevPreparedSeal: WBFTAggregatedSeal

  # Previous block's commit seal
  prevCommittedSeal: WBFTAggregatedSeal

  # Current round number
  round: Int!

  # Prepare phase aggregated seal
  preparedSeal: WBFTAggregatedSeal

  # Commit phase aggregated seal
  committedSeal: WBFTAggregatedSeal

  # Gas tip value agreed through governance
  gasTip: BigInt

  # Epoch info (only for last block of epoch)
  epochInfo: EpochInfo

  # Block timestamp
  timestamp: BigInt!
}

# ValidatorSigningStats represents signing statistics for a validator
type ValidatorSigningStats {
  # Validator address
  validatorAddress: Address!

  # Validator index
  validatorIndex: Int!

  # Total number of prepare signatures
  prepareSignCount: BigInt!

  # Total number of missed prepare signatures
  prepareMissCount: BigInt!

  # Total number of commit signatures
  commitSignCount: BigInt!

  # Total number of missed commit signatures
  commitMissCount: BigInt!

  # Block range start
  fromBlock: BigInt!

  # Block range end
  toBlock: BigInt!

  # Signing rate percentage
  signingRate: Float!

  # Number of blocks proposed by this validator
  blocksProposed: BigInt!

  # Total number of blocks in the query range
  totalBlocks: BigInt!

  # Block proposal rate percentage
  proposalRate: Float
}

# ValidatorSigningActivity represents a validator's signing activity for a specific block
type ValidatorSigningActivity {
  # Block number
  blockNumber: BigInt!

  # Block hash
  blockHash: Hash!

  # Validator address
  validatorAddress: Address!

  # Validator index
  validatorIndex: Int!

  # Whether validator signed in prepare phase
  signedPrepare: Boolean!

  # Whether validator signed in commit phase
  signedCommit: Boolean!

  # Round number
  round: Int!

  # Block timestamp
  timestamp: BigInt!
}

# BlockSigners represents validators who signed a specific block
type BlockSigners {
  # Block number
  blockNumber: BigInt!

  # Validators who signed in prepare phase
  preparers: [Address!]!

  # Validators who signed in commit phase
  committers: [Address!]!
}

# Connections for pagination
type ValidatorSigningStatsConnection {
  nodes: [ValidatorSigningStats!]!
  totalCount: Int!
  pageInfo: PageInfo!
}

type ValidatorSigningActivityConnection {
  nodes: [ValidatorSigningActivity!]!
  totalCount: Int!
  pageInfo: PageInfo!
}

# Epoch summary (lightweight, for list queries)
type EpochSummary {
  epochNumber: BigInt!
  blockNumber: BigInt!
  validatorCount: Int!
  candidateCount: Int!
  timestamp: BigInt
}

type EpochSummaryConnection {
  nodes: [EpochSummary!]!
  totalCount: Int!
  pageInfo: PageInfo!
}

# ========== Enhanced Consensus Types ==========

# ConsensusData represents complete consensus information for a block
type ConsensusData {
  # Block identification
  blockNumber: BigInt!
  blockHash: Hash!

  # Round information
  round: Int!
  prevRound: Int!
  roundChanged: Boolean!

  # Validator participation
  proposer: Address!
  validators: [Address!]!
  prepareSigners: [Address!]!
  commitSigners: [Address!]!

  # Participation metrics
  prepareCount: Int!
  commitCount: Int!
  missedPrepare: [Address!]!
  missedCommit: [Address!]!

  # Additional data
  vanityData: Bytes
  randaoReveal: Bytes
  gasTip: BigInt

  # Epoch information
  epochInfo: EpochData
  isEpochBoundary: Boolean!

  # Metadata
  timestamp: BigInt!

  # Calculated metrics
  participationRate: Float!
  isHealthy: Boolean!
}

# EpochData represents enhanced epoch information
type EpochData {
  # Epoch number
  epochNumber: BigInt!

  # Validator and candidate counts
  validatorCount: Int!
  candidateCount: Int!

  # Validators in this epoch
  validators: [ValidatorInfoDetailed!]!

  # Candidates for next epoch
  candidates: [CandidateInfo!]!
}

# ValidatorInfoDetailed represents detailed validator information
type ValidatorInfoDetailed {
  # Validator address
  address: Address!

  # Validator index in the set
  index: Int!

  # BLS public key
  blsPubKey: Bytes
}

# CandidateInfo represents a validator candidate
type CandidateInfo {
  # Candidate address
  address: Address!

  # Diligence score (0-2,000,000)
  diligence: BigInt!
}

# ValidatorStats represents enhanced validator statistics
type ValidatorStats {
  # Validator address
  address: Address!

  # Block production
  totalBlocks: BigInt!
  blocksProposed: BigInt!

  # Participation metrics
  preparesSigned: BigInt!
  commitsSigned: BigInt!
  preparesMissed: BigInt!
  commitsMissed: BigInt!
  participationRate: Float!

  # Recent activity tracking
  lastProposedBlock: BigInt
  lastCommittedBlock: BigInt
  lastSeenBlock: BigInt
}

# ValidatorParticipation provides detailed participation data over a range
type ValidatorParticipation {
  # Validator address
  address: Address!

  # Block range
  startBlock: BigInt!
  endBlock: BigInt!

  # Aggregated statistics
  totalBlocks: BigInt!
  blocksProposed: BigInt!
  blocksCommitted: BigInt!
  blocksMissed: BigInt!
  participationRate: Float!

  # Per-block breakdown
  blocks: [BlockParticipation!]!
}

# BlockParticipation represents a validator's participation in a specific block
type BlockParticipation {
  blockNumber: BigInt!
  wasProposer: Boolean!
  signedPrepare: Boolean!
  signedCommit: Boolean!
  round: Int!
}

# RoundAnalysis provides statistical analysis of round changes
type RoundAnalysis {
  # Block range
  startBlock: BigInt!
  endBlock: BigInt!

  # Statistics
  totalBlocks: BigInt!
  blocksWithRoundChange: BigInt!
  roundChangeRate: Float!
  averageRound: Float!
  maxRound: Int!

  # Round distribution
  roundDistribution: [RoundDistribution!]!
}

# RoundDistribution shows the distribution of blocks by round number
type RoundDistribution {
  round: Int!
  count: BigInt!
  percentage: Float!
}

# ValidatorSet represents the active validator set at a specific point
type ValidatorSet {
  blockNumber: BigInt!
  epochNumber: BigInt
  validators: [Address!]!
  count: Int!
}

# ValidatorActivity tracks real-time validator activity
type ValidatorActivity {
  address: Address!
  isActive: Boolean!
  isOnline: Boolean!
  lastSeen: BigInt!
  blocksAgo: BigInt!
  currentStreak: BigInt!
}

# ValidatorChange represents a change in validator set at epoch boundary
type ValidatorChange {
  epochNumber: BigInt!
  blockNumber: BigInt!
  previousValidators: [Address!]!
  newValidators: [Address!]!
  addedValidators: [Address!]!
  removedValidators: [Address!]!
}

# ========== Address Indexing Types ==========

# ContractCreation represents a contract creation event
type ContractCreation {
  # Created contract address
  contractAddress: Address!

  # Contract name (from verification data, null if not verified)
  name: String

  # Creator address
  creator: Address!

  # Transaction hash that created the contract
  transactionHash: Hash!

  # Block number
  blockNumber: BigInt!

  # Timestamp
  timestamp: BigInt!

  # Deployed bytecode size
  bytecodeSize: Int!
}

# ContractVerification represents verified contract source code
type ContractVerification {
  # Contract address
  address: Address!

  # Whether the contract is verified
  isVerified: Boolean!

  # Contract name
  name: String

  # Solidity compiler version (e.g., "0.8.20")
  compilerVersion: String

  # Whether optimization was enabled during compilation
  optimizationEnabled: Boolean

  # Number of optimization runs
  optimizationRuns: Int

  # Verified source code
  sourceCode: String

  # Contract ABI (JSON string)
  abi: String

  # Constructor arguments (encoded)
  constructorArguments: String

  # Verification timestamp
  verifiedAt: String

  # License type (e.g., "MIT", "GPL-3.0")
  licenseType: String
}

# InternalTransaction represents an internal call during transaction execution
type InternalTransaction {
  # Original transaction hash
  transactionHash: Hash!

  # Block number
  blockNumber: BigInt!

  # Order index
  index: Int!

  # Type: CALL, DELEGATECALL, STATICCALL, CREATE, etc.
  type: String!

  # Caller address
  from: Address!

  # Callee address (or created address for CREATE)
  to: Address!

  # Transferred ETH amount (wei)
  value: BigInt!

  # Allocated gas
  gas: BigInt!

  # Used gas
  gasUsed: BigInt!

  # Call data
  input: Bytes!

  # Return data
  output: Bytes!

  # Error message (if failed)
  error: String

  # Call depth (0 = root)
  depth: Int!
}

# ERC20Transfer represents an ERC20 token transfer
type ERC20Transfer {
  # Token contract address
  contractAddress: Address!

  # Sender address
  from: Address!

  # Recipient address
  to: Address!

  # Transfer amount
  value: BigInt!

  # Transaction hash
  transactionHash: Hash!

  # Block number
  blockNumber: BigInt!

  # Log index
  logIndex: Int!

  # Timestamp
  timestamp: BigInt!
}

# ERC721Transfer represents an ERC721 NFT transfer
type ERC721Transfer {
  # NFT contract address
  contractAddress: Address!

  # Sender address
  from: Address!

  # Recipient address
  to: Address!

  # Token ID
  tokenId: BigInt!

  # Transaction hash
  transactionHash: Hash!

  # Block number
  blockNumber: BigInt!

  # Log index
  logIndex: Int!

  # Timestamp
  timestamp: BigInt!
}

# Connections for address indexing pagination
type ContractCreationConnection {
  nodes: [ContractCreation!]!
  totalCount: Int!
  pageInfo: PageInfo!
}

type InternalTransactionConnection {
  nodes: [InternalTransaction!]!
  totalCount: Int!
  pageInfo: PageInfo!
}

type ERC20TransferConnection {
  nodes: [ERC20Transfer!]!
  totalCount: Int!
  pageInfo: PageInfo!
}

type ERC721TransferConnection {
  nodes: [ERC721Transfer!]!
  totalCount: Int!
  pageInfo: PageInfo!
}

# NFTOwnership represents an NFT owned by an address
type NFTOwnership {
  # NFT contract address
  contractAddress: Address!

  # Token ID
  tokenId: BigInt!

  # Owner address
  owner: Address!
}

# NFTOwnershipConnection for paginated NFT ownership queries
type NFTOwnershipConnection {
  nodes: [NFTOwnership!]!
  totalCount: Int!
  pageInfo: PageInfo!
}

# Registered Contract for dynamic event parsing
type RegisteredContract {
  # Contract address
  address: Address!

  # Contract name
  name: String!

  # Contract ABI (JSON string)
  abi: String!

  # Registration timestamp
  registeredAt: BigInt!

  # Block number when registered
  blockNumber: BigInt!

  # Whether the contract is verified
  isVerified: Boolean!

  # List of event names in the ABI
  events: [String!]!
}

# Input for registering a contract
input RegisterContractInput {
  # Contract address
  address: Address!

  # Human-readable contract name
  name: String!

  # Contract ABI JSON string
  abi: String!

  # Block number to start parsing from
  blockNumber: BigInt
}

# Dynamic contract event
type DynamicContractEvent {
  # Contract address
  contract: Address!

  # Contract name
  contractName: String!

  # Event name
  eventName: String!

  # Block number
  blockNumber: BigInt!

  # Transaction hash
  txHash: Hash!

  # Log index
  logIndex: Int!

  # Event data as JSON string
  data: String!

  # Timestamp
  timestamp: BigInt!
}

# Filter for dynamic contract events
input DynamicContractEventFilter {
  # Filter by contract address
  contract: Address

  # Filter by event names
  eventNames: [String!]

  # Filter by block range
  fromBlock: BigInt
  toBlock: BigInt
}

# ========== RPC Proxy Types ==========

# Live balance result from chain RPC
type LiveBalanceResult {
  # Account address
  address: Address!
  # Account balance in wei
  balance: BigInt!
  # Block number at which balance was queried
  blockNumber: BigInt!
}

# Contract call result
type ContractCallResult {
  # Decoded result (if ABI available)
  result: String
  # Raw hex result
  rawResult: String!
  # Whether the result was successfully decoded
  decoded: Boolean!
}

# Transaction status result
type TransactionStatusResult {
  # Transaction hash
  txHash: Hash!
  # Current status (pending, success, failed, not_found, confirmed)
  status: String!
  # Block number (if mined)
  blockNumber: BigInt
  # Block hash (if mined)
  blockHash: Hash
  # Number of confirmations
  confirmations: BigInt!
  # Gas used (if mined)
  gasUsed: BigInt
}

# Internal transactions result from RPC
type InternalTransactionsRPCResult {
  # Transaction hash
  txHash: Hash!
  # List of internal transactions
  internalTransactions: [InternalTransactionRPC!]!
  # Total count
  totalCount: Int!
}

# Internal transaction from RPC trace
type InternalTransactionRPC {
  # Call type (CALL, CREATE, DELEGATECALL, etc.)
  type: String!
  # From address
  from: Address!
  # To address
  to: Address!
  # Value transferred
  value: BigInt!
  # Gas provided
  gas: BigInt!
  # Gas used
  gasUsed: BigInt!
  # Input data
  input: String!
  # Output data
  output: String!
  # Error message if failed
  error: String
  # Call depth
  depth: Int!
  # Trace address (path in call tree)
  traceAddress: [Int!]!
}

# RPC Proxy service metrics
type RPCProxyMetrics {
  # Total number of requests processed
  totalRequests: BigInt!
  # Number of successful requests
  successfulRequests: BigInt!
  # Number of failed requests
  failedRequests: BigInt!
  # Number of cache hits
  cacheHits: BigInt!
  # Number of cache misses
  cacheMisses: BigInt!
  # Average response latency in milliseconds
  averageLatency: BigInt!
  # Current request queue depth
  queueDepth: Int!
  # Number of active workers
  activeWorkers: Int!
  # Circuit breaker state (closed, open, half-open)
  circuitState: String!
}

# ========== Address Stats Types ==========

# AddressStats represents aggregated statistics for an address
type AddressStats {
  # Address being queried
  address: Address!
  # Total number of transactions
  totalTransactions: Int!
  # Number of sent transactions
  sentCount: Int!
  # Number of received transactions
  receivedCount: Int!
  # Number of successful transactions
  successCount: Int!
  # Number of failed transactions
  failedCount: Int!
  # Total gas used across all transactions
  totalGasUsed: BigInt!
  # Total gas cost in wei (gasUsed * effectiveGasPrice)
  totalGasCost: BigInt!
  # Total value sent in wei
  totalValueSent: BigInt!
  # Total value received in wei
  totalValueReceived: BigInt!
  # Number of contract interactions
  contractInteractionCount: Int!
  # Number of unique addresses interacted with
  uniqueAddressCount: Int!
  # Timestamp of first transaction (null if no transactions)
  firstTransactionTimestamp: BigInt
  # Timestamp of last transaction (null if no transactions)
  lastTransactionTimestamp: BigInt
}

# ========== Fee Delegation Types ==========

# Overall fee delegation statistics
type FeeDelegationStats {
  # Total number of fee delegation transactions
  totalFeeDelegatedTxs: BigInt!
  # Total fees saved by users (paid by fee payers) in wei
  totalFeesSaved: BigInt!
  # Percentage of fee delegation transactions vs total transactions
  adoptionRate: Float!
  # Average fee saved per fee delegation transaction in wei
  avgFeeSaved: BigInt!
}

# Statistics for a single fee payer
type FeePayerStats {
  # Fee payer address
  address: Address!
  # Number of transactions sponsored by this fee payer
  txCount: BigInt!
  # Total fees paid by this fee payer in wei
  totalFeesPaid: BigInt!
  # Percentage of total fee delegation transactions
  percentage: Float!
}

# Top fee payers result with pagination info
type TopFeePayersResult {
  # List of fee payer statistics
  nodes: [FeePayerStats!]!
  # Total count of unique fee payers
  totalCount: BigInt!
}

# ========== Token Metadata Types ==========

# Token standard enum
enum TokenStandard {
  UNKNOWN
  ERC20
  ERC721
  ERC1155
}

# Token metadata represents cached information about a token contract
type TokenMetadata {
  # Token contract address
  address: Address!

  # Detected token standard
  standard: TokenStandard!

  # Token name (from name() function)
  name: String

  # Token symbol (from symbol() function)
  symbol: String

  # Number of decimals (ERC20 only, 0 for NFTs)
  decimals: Int!

  # Total supply (ERC20 only)
  totalSupply: BigInt

  # Base URI for token metadata (ERC721/ERC1155)
  baseURI: String

  # Block height when the token was first detected
  detectedAt: BigInt!

  # Timestamp when metadata was created
  createdAt: DateTime!

  # Timestamp when metadata was last updated
  updatedAt: DateTime!

  # Whether the contract supports ERC-165 interface detection
  supportsERC165: Boolean!

  # Whether the contract supports metadata extension
  supportsMetadata: Boolean!

  # Whether ERC721 contract supports enumerable extension
  supportsEnumerable: Boolean
}

# Token metadata connection for pagination
type TokenMetadataConnection {
  # List of token metadata
  nodes: [TokenMetadata!]!

  # Total count
  totalCount: Int!

  # Page info
  pageInfo: PageInfo!
}

# Mutation type for write operations
type Mutation {
  # ========== Multi-Chain Mutations ==========

  # Register a new chain for indexing
  registerChain(input: RegisterChainInput!): Chain!

  # Start indexing a registered chain
  startChain(id: ID!): Chain!

  # Stop indexing a chain
  stopChain(id: ID!): Chain!

  # Unregister a chain (must be stopped first)
  unregisterChain(id: ID!): Boolean!

  # ========== Watchlist Mutations ==========

  # Watch an address for events
  watchAddress(input: WatchAddressInput!): WatchedAddress!

  # Stop watching an address
  unwatchAddress(id: ID!): Boolean!

  # Update watch filter for an address
  updateWatchFilter(id: ID!, filter: WatchFilterInput!): WatchedAddress!

  # ========== Existing Mutations ==========

  # Verify a contract's source code
  verifyContract(
    address: Address!
    sourceCode: String!
    compilerVersion: String!
    optimizationEnabled: Boolean!
    optimizationRuns: Int
    constructorArguments: String
    contractName: String
    licenseType: String
  ): ContractVerification!

  # Register a contract for dynamic event parsing
  registerContract(input: RegisterContractInput!): RegisteredContract!

  # Unregister a contract from dynamic event parsing
  unregisterContract(address: Address!): Boolean!
}
